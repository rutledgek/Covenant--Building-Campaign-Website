(function ($) {
    window.Rock = window.Rock || {};

    Rock.dialogs = (function () {
        var _dialogs = {},
            exports = {
                // Presents a bootstrap style alert box with the specified message 
                // then executes the callback function(result)
                alert: function (msg) {
                    bootbox.dialog({
                        message: msg,
                        buttons: {
                            ok: {
                                label: 'OK',
                                className: 'btn-primary'
                            }
                        }
                    });
                },

                // Presents a bootstrap style alert box with the specified message 
                // then executes the callback function(result)
                confirm: function (msg, callback) {
                    bootbox.dialog({
                        message: msg,
                        buttons: {
                            ok: {
                                label: 'OK',
                                className: 'btn-primary',
                                callback: function () {
                                    callback(true);
                                }
                            },
                            cancel: {
                                label: 'Cancel',
                                className: 'btn-secondary',
                                callback: function () {
                                    callback(false);
                                }
                            }
                        }
                    });
                },

                // Presents a bootstrap style alert box with a 'Are you sure you want to delete this ...' message 
                // Returns true if the user selects OK
                confirmDelete: function (e, nameText, additionalMsg) {
                    // make sure the element that triggered this event isn't disabled
                    if (e.currentTarget && e.currentTarget.disabled) {
                        return false;
                    }

                    e.preventDefault();
                    var msg = 'Are you sure you want to delete this ' + nameText + '?';
                    if (additionalMsg) {
                        msg += ' ' + additionalMsg;
                    }

                    bootbox.dialog({
                        message: msg,
                        buttons: {
                            ok: {
                                label: 'OK',
                                className: 'btn-primary',
                                callback: function () {
                                    var postbackJs = e.target.href ? e.target.href : e.target.parentElement.href;
                                    window.location = postbackJs;
                                }
                            },
                            cancel: {
                                label: 'Cancel',
                                className: 'btn-secondary'
                            }
                        }
                    });
                },

                // Updates the modal so that scrolling works
                updateModalScrollBar: function (controlId) {
                    Rock.controls.modal.updateSize(controlId);
                }
            }

        return exports;
    }());
}(jQuery));;
(function () {
    'use strict';
    window.Rock = window.Rock || {};
    Rock.settings = (function () {
        var _settings = {},
            exports = {
                initialize: function (options) {
                    if (typeof options === 'object') {
                        _settings = options;
                    }
                },
                get: function (key) {
                    return _settings[key];
                },
                insert: function (key, value) {
                    _settings[key] = value;
                },
                remove: function (key) {
                    if (_settings[key]) {
                        delete _settings[key];
                    }
                }
            };
 
        return exports;
    }());
}());;
(function () {
    'use strict';
    window.Rock = window.Rock || {};

    Rock.utility = (function () {
        var _utility = {},
            exports = {

                setContext: function (restController, entityId) {
                    // Get the current block instance object
                    $.ajax({
                        type: 'PUT',
                        url: Rock.settings.get('baseUrl') + 'api/' + restController + '/SetContext/' + entityId,
                        success: function (getData, status, xhr) {
                        },
                        error: function (xhr, status, error) {
                            alert(status + ' [' + error + ']: ' + xhr.responseText);
                        }
                    });
                },
            };
 
        return exports;
    }());
}());;
(function ($) {
    'use strict';
    window.Rock = window.Rock || {};
    Rock.controls = Rock.controls || {};

    Rock.controls.autoCompleteDropDown = (function () {
        var exports,
            AutoCompleteDropDown = function (options) {
                this.controlId = options.controlId;
                this.valueControlId = options.valueControlId;
                this.$el = $('#' + this.controlId);
                this.name = options.name;
                this.url = options.url;
                this.limit = options.limit;
                this.idProperty = options.idProperty;
                this.valuekey = options.valuekey;
                this.template = options.template;
                this.header = options.header;
                this.footer = options.footer;
            };

        AutoCompleteDropDown.prototype = {
            constructor: AutoCompleteDropDown,
            initialize: function () {
                var self = this,
                    Liquid = require('liquid'),
                    liquidEngine = {
                        compile: function (template) {
                            var parsedTemplate = Liquid.Template.parse(template);
                            return {
                                render: function (context) {
                                    return parsedTemplate.render(context);
                                }
                            };
                        }
                    };

                this.$el.typeahead({
                    name: this.name,
                    limit: this.limit,
                    valueKey: this.valuekey,
                    template: this.template,
                    header: this.header,
                    footer: this.footer,
                    engine: liquidEngine,
                    remote: {
                        url: Rock.settings.get('baseUrl') + this.url,
                        filter: function (response) {
                            response.forEach(function (item) {
                                item['tokens'] = item[self.valuekey].replace(/,/g, '').split(" ");
                            });
                            return response;
                        }
                    }
                });

                this.initializeEventHandlers();
            },

            initializeEventHandlers: function () {
                var self = this,
                    idProperty = this.idProperty,
                    setValue = function (datum) {
                        $('#' + self.valueControlId).val(datum[idProperty]);
                    };

                // Listen for typeahead's custom events and trigger search when hit
                this.$el.on('typeahead:selected typeahead:autocompleted', function (e, obj, name) {
                    setValue(obj);
                    if (typeof self.onSelected === "function") {
                        self.onSelected(obj);
                    }
                });

            }
        };

        exports = {
            defaults: {
                controlId: null,
                name: 'autoComplete',
                valueControlId: null,
                limit: 5,
                idProperty: 'Id',
                valuekey: 'value',
                template: '<p>{{value}}</p>',
                header: '',
                footer: ''
            },
            initialize: function (options) {
                var autoCompleteDropDown,
                    settings = $.extend({}, exports.defaults, options);

                if (!settings.controlId) throw 'controlId is required';
                if (!settings.valueControlId) throw 'valueControlId is required';
                if (!settings.url) throw 'url is required';

                autoCompleteDropDown = new AutoCompleteDropDown(settings);

                // Delay initialization until after the DOM is ready
                $(function () {
                    autoCompleteDropDown.initialize();
                });

                return autoCompleteDropDown;
            }
        };

        return exports;
    }());
}(jQuery));;
!function(a){"use strict";"object"==typeof exports?module.exports=a(window.jQuery):"function"==typeof define&&define.amd?define(["jquery"],a):window.jQuery&&!window.jQuery.fn.colorpicker&&a(window.jQuery)}(function(a){"use strict";var b=function(b,c){this.value={h:0,s:0,b:0,a:1},this.origFormat=null,c&&a.extend(this.colors,c),b&&(void 0!==b.toLowerCase?(b+="",this.setColor(b)):void 0!==b.h&&(this.value=b))};b.prototype={constructor:b,colors:{aliceblue:"#f0f8ff",antiquewhite:"#faebd7",aqua:"#00ffff",aquamarine:"#7fffd4",azure:"#f0ffff",beige:"#f5f5dc",bisque:"#ffe4c4",black:"#000000",blanchedalmond:"#ffebcd",blue:"#0000ff",blueviolet:"#8a2be2",brown:"#a52a2a",burlywood:"#deb887",cadetblue:"#5f9ea0",chartreuse:"#7fff00",chocolate:"#d2691e",coral:"#ff7f50",cornflowerblue:"#6495ed",cornsilk:"#fff8dc",crimson:"#dc143c",cyan:"#00ffff",darkblue:"#00008b",darkcyan:"#008b8b",darkgoldenrod:"#b8860b",darkgray:"#a9a9a9",darkgreen:"#006400",darkkhaki:"#bdb76b",darkmagenta:"#8b008b",darkolivegreen:"#556b2f",darkorange:"#ff8c00",darkorchid:"#9932cc",darkred:"#8b0000",darksalmon:"#e9967a",darkseagreen:"#8fbc8f",darkslateblue:"#483d8b",darkslategray:"#2f4f4f",darkturquoise:"#00ced1",darkviolet:"#9400d3",deeppink:"#ff1493",deepskyblue:"#00bfff",dimgray:"#696969",dodgerblue:"#1e90ff",firebrick:"#b22222",floralwhite:"#fffaf0",forestgreen:"#228b22",fuchsia:"#ff00ff",gainsboro:"#dcdcdc",ghostwhite:"#f8f8ff",gold:"#ffd700",goldenrod:"#daa520",gray:"#808080",green:"#008000",greenyellow:"#adff2f",honeydew:"#f0fff0",hotpink:"#ff69b4",indianred:"#cd5c5c",indigo:"#4b0082",ivory:"#fffff0",khaki:"#f0e68c",lavender:"#e6e6fa",lavenderblush:"#fff0f5",lawngreen:"#7cfc00",lemonchiffon:"#fffacd",lightblue:"#add8e6",lightcoral:"#f08080",lightcyan:"#e0ffff",lightgoldenrodyellow:"#fafad2",lightgrey:"#d3d3d3",lightgreen:"#90ee90",lightpink:"#ffb6c1",lightsalmon:"#ffa07a",lightseagreen:"#20b2aa",lightskyblue:"#87cefa",lightslategray:"#778899",lightsteelblue:"#b0c4de",lightyellow:"#ffffe0",lime:"#00ff00",limegreen:"#32cd32",linen:"#faf0e6",magenta:"#ff00ff",maroon:"#800000",mediumaquamarine:"#66cdaa",mediumblue:"#0000cd",mediumorchid:"#ba55d3",mediumpurple:"#9370d8",mediumseagreen:"#3cb371",mediumslateblue:"#7b68ee",mediumspringgreen:"#00fa9a",mediumturquoise:"#48d1cc",mediumvioletred:"#c71585",midnightblue:"#191970",mintcream:"#f5fffa",mistyrose:"#ffe4e1",moccasin:"#ffe4b5",navajowhite:"#ffdead",navy:"#000080",oldlace:"#fdf5e6",olive:"#808000",olivedrab:"#6b8e23",orange:"#ffa500",orangered:"#ff4500",orchid:"#da70d6",palegoldenrod:"#eee8aa",palegreen:"#98fb98",paleturquoise:"#afeeee",palevioletred:"#d87093",papayawhip:"#ffefd5",peachpuff:"#ffdab9",peru:"#cd853f",pink:"#ffc0cb",plum:"#dda0dd",powderblue:"#b0e0e6",purple:"#800080",red:"#ff0000",rosybrown:"#bc8f8f",royalblue:"#4169e1",saddlebrown:"#8b4513",salmon:"#fa8072",sandybrown:"#f4a460",seagreen:"#2e8b57",seashell:"#fff5ee",sienna:"#a0522d",silver:"#c0c0c0",skyblue:"#87ceeb",slateblue:"#6a5acd",slategray:"#708090",snow:"#fffafa",springgreen:"#00ff7f",steelblue:"#4682b4",tan:"#d2b48c",teal:"#008080",thistle:"#d8bfd8",tomato:"#ff6347",turquoise:"#40e0d0",violet:"#ee82ee",wheat:"#f5deb3",white:"#ffffff",whitesmoke:"#f5f5f5",yellow:"#ffff00",yellowgreen:"#9acd32",transparent:"transparent"},_sanitizeNumber:function(a){return"number"==typeof a?a:isNaN(a)||null===a||""===a||void 0===a?1:void 0!==a.toLowerCase?parseFloat(a):1},isTransparent:function(a){return a?(a=a.toLowerCase().trim(),"transparent"===a||a.match(/#?00000000/)||a.match(/(rgba|hsla)\(0,0,0,0?\.?0\)/)):!1},rgbaIsTransparent:function(a){return 0===a.r&&0===a.g&&0===a.b&&0===a.a},setColor:function(a){a=a.toLowerCase().trim(),a&&(this.isTransparent(a)?this.value={h:0,s:0,b:0,a:0}:this.value=this.stringToHSB(a)||{h:0,s:0,b:0,a:1})},stringToHSB:function(b){b=b.toLowerCase();var c;"undefined"!=typeof this.colors[b]&&(b=this.colors[b],c="alias");var d=this,e=!1;return a.each(this.stringParsers,function(a,f){var g=f.re.exec(b),h=g&&f.parse.apply(d,[g]),i=c||f.format||"rgba";return h?(e=i.match(/hsla?/)?d.RGBtoHSB.apply(d,d.HSLtoRGB.apply(d,h)):d.RGBtoHSB.apply(d,h),d.origFormat=i,!1):!0}),e},setHue:function(a){this.value.h=1-a},setSaturation:function(a){this.value.s=a},setBrightness:function(a){this.value.b=1-a},setAlpha:function(a){this.value.a=parseInt(100*(1-a),10)/100},toRGB:function(a,b,c,d){a||(a=this.value.h,b=this.value.s,c=this.value.b),a*=360;var e,f,g,h,i;return a=a%360/60,i=c*b,h=i*(1-Math.abs(a%2-1)),e=f=g=c-i,a=~~a,e+=[i,h,0,0,h,i][a],f+=[h,i,i,h,0,0][a],g+=[0,0,h,i,i,h][a],{r:Math.round(255*e),g:Math.round(255*f),b:Math.round(255*g),a:d||this.value.a}},toHex:function(a,b,c,d){var e=this.toRGB(a,b,c,d);return this.rgbaIsTransparent(e)?"transparent":"#"+(1<<24|parseInt(e.r)<<16|parseInt(e.g)<<8|parseInt(e.b)).toString(16).substr(1)},toHSL:function(a,b,c,d){a=a||this.value.h,b=b||this.value.s,c=c||this.value.b,d=d||this.value.a;var e=a,f=(2-b)*c,g=b*c;return g/=f>0&&1>=f?f:2-f,f/=2,g>1&&(g=1),{h:isNaN(e)?0:e,s:isNaN(g)?0:g,l:isNaN(f)?0:f,a:isNaN(d)?0:d}},toAlias:function(a,b,c,d){var e=this.toHex(a,b,c,d);for(var f in this.colors)if(this.colors[f]===e)return f;return!1},RGBtoHSB:function(a,b,c,d){a/=255,b/=255,c/=255;var e,f,g,h;return g=Math.max(a,b,c),h=g-Math.min(a,b,c),e=0===h?null:g===a?(b-c)/h:g===b?(c-a)/h+2:(a-b)/h+4,e=(e+360)%6*60/360,f=0===h?0:h/g,{h:this._sanitizeNumber(e),s:f,b:g,a:this._sanitizeNumber(d)}},HueToRGB:function(a,b,c){return 0>c?c+=1:c>1&&(c-=1),1>6*c?a+(b-a)*c*6:1>2*c?b:2>3*c?a+(b-a)*(2/3-c)*6:a},HSLtoRGB:function(a,b,c,d){0>b&&(b=0);var e;e=.5>=c?c*(1+b):c+b-c*b;var f=2*c-e,g=a+1/3,h=a,i=a-1/3,j=Math.round(255*this.HueToRGB(f,e,g)),k=Math.round(255*this.HueToRGB(f,e,h)),l=Math.round(255*this.HueToRGB(f,e,i));return[j,k,l,this._sanitizeNumber(d)]},toString:function(a){a=a||"rgba";var b=!1;switch(a){case"rgb":return b=this.toRGB(),this.rgbaIsTransparent(b)?"transparent":"rgb("+b.r+","+b.g+","+b.b+")";case"rgba":return b=this.toRGB(),"rgba("+b.r+","+b.g+","+b.b+","+b.a+")";case"hsl":return b=this.toHSL(),"hsl("+Math.round(360*b.h)+","+Math.round(100*b.s)+"%,"+Math.round(100*b.l)+"%)";case"hsla":return b=this.toHSL(),"hsla("+Math.round(360*b.h)+","+Math.round(100*b.s)+"%,"+Math.round(100*b.l)+"%,"+b.a+")";case"hex":return this.toHex();case"alias":return this.toAlias()||this.toHex();default:return b}},stringParsers:[{re:/rgb\(\s*(\d{1,3})\s*,\s*(\d{1,3})\s*,\s*(\d{1,3})\s*?\)/,format:"rgb",parse:function(a){return[a[1],a[2],a[3],1]}},{re:/rgb\(\s*(\d+(?:\.\d+)?)\%\s*,\s*(\d+(?:\.\d+)?)\%\s*,\s*(\d+(?:\.\d+)?)\%\s*?\)/,format:"rgb",parse:function(a){return[2.55*a[1],2.55*a[2],2.55*a[3],1]}},{re:/rgba\(\s*(\d{1,3})\s*,\s*(\d{1,3})\s*,\s*(\d{1,3})\s*(?:,\s*(\d+(?:\.\d+)?)\s*)?\)/,format:"rgba",parse:function(a){return[a[1],a[2],a[3],a[4]]}},{re:/rgba\(\s*(\d+(?:\.\d+)?)\%\s*,\s*(\d+(?:\.\d+)?)\%\s*,\s*(\d+(?:\.\d+)?)\%\s*(?:,\s*(\d+(?:\.\d+)?)\s*)?\)/,format:"rgba",parse:function(a){return[2.55*a[1],2.55*a[2],2.55*a[3],a[4]]}},{re:/hsl\(\s*(\d+(?:\.\d+)?)\s*,\s*(\d+(?:\.\d+)?)\%\s*,\s*(\d+(?:\.\d+)?)\%\s*?\)/,format:"hsl",parse:function(a){return[a[1]/360,a[2]/100,a[3]/100,a[4]]}},{re:/hsla\(\s*(\d+(?:\.\d+)?)\s*,\s*(\d+(?:\.\d+)?)\%\s*,\s*(\d+(?:\.\d+)?)\%\s*(?:,\s*(\d+(?:\.\d+)?)\s*)?\)/,format:"hsla",parse:function(a){return[a[1]/360,a[2]/100,a[3]/100,a[4]]}},{re:/#?([a-fA-F0-9]{2})([a-fA-F0-9]{2})([a-fA-F0-9]{2})/,format:"hex",parse:function(a){return[parseInt(a[1],16),parseInt(a[2],16),parseInt(a[3],16),1]}},{re:/#?([a-fA-F0-9])([a-fA-F0-9])([a-fA-F0-9])/,format:"hex",parse:function(a){return[parseInt(a[1]+a[1],16),parseInt(a[2]+a[2],16),parseInt(a[3]+a[3],16),1]}}],colorNameToHex:function(a){return"undefined"!=typeof this.colors[a.toLowerCase()]?this.colors[a.toLowerCase()]:!1}};var c={horizontal:!1,inline:!1,color:!1,format:!1,input:"input",container:!1,component:".add-on, .input-group-addon",sliders:{saturation:{maxLeft:100,maxTop:100,callLeft:"setSaturation",callTop:"setBrightness"},hue:{maxLeft:0,maxTop:100,callLeft:!1,callTop:"setHue"},alpha:{maxLeft:0,maxTop:100,callLeft:!1,callTop:"setAlpha"}},slidersHorz:{saturation:{maxLeft:100,maxTop:100,callLeft:"setSaturation",callTop:"setBrightness"},hue:{maxLeft:100,maxTop:0,callLeft:"setHue",callTop:!1},alpha:{maxLeft:100,maxTop:0,callLeft:"setAlpha",callTop:!1}},template:'<div class="colorpicker dropdown-menu"><div class="colorpicker-saturation"><i><b></b></i></div><div class="colorpicker-hue"><i></i></div><div class="colorpicker-alpha"><i></i></div><div class="colorpicker-color"><div /></div><div class="colorpicker-selectors"></div></div>',align:"right",customClass:null,colorSelectors:null},d=function(d,e){if(this.element=a(d).addClass("colorpicker-element"),this.options=a.extend(!0,{},c,this.element.data(),e),this.component=this.options.component,this.component=this.component!==!1?this.element.find(this.component):!1,this.component&&0===this.component.length&&(this.component=!1),this.container=this.options.container===!0?this.element:this.options.container,this.container=this.container!==!1?a(this.container):!1,this.input=this.element.is("input")?this.element:this.options.input?this.element.find(this.options.input):!1,this.input&&0===this.input.length&&(this.input=!1),this.color=new b(this.options.color!==!1?this.options.color:this.getValue(),this.options.colorSelectors),this.format=this.options.format!==!1?this.options.format:this.color.origFormat,this.picker=a(this.options.template),this.options.customClass&&this.picker.addClass(this.options.customClass),this.options.inline?this.picker.addClass("colorpicker-inline colorpicker-visible"):this.picker.addClass("colorpicker-hidden"),this.options.horizontal&&this.picker.addClass("colorpicker-horizontal"),("rgba"===this.format||"hsla"===this.format||this.options.format===!1)&&this.picker.addClass("colorpicker-with-alpha"),"right"===this.options.align&&this.picker.addClass("colorpicker-right"),this.options.colorSelectors){var f=this;a.each(this.options.colorSelectors,function(b,c){var d=a("<i />").css("background-color",c).data("class",b);d.click(function(){f.setValue(a(this).css("background-color"))}),f.picker.find(".colorpicker-selectors").append(d)}),this.picker.find(".colorpicker-selectors").show()}this.picker.on("mousedown.colorpicker touchstart.colorpicker",a.proxy(this.mousedown,this)),this.picker.appendTo(this.container?this.container:a("body")),this.input!==!1&&(this.input.on({"keyup.colorpicker":a.proxy(this.keyup,this)}),this.input.on({"change.colorpicker":a.proxy(this.change,this)}),this.component===!1&&this.element.on({"focus.colorpicker":a.proxy(this.show,this)}),this.options.inline===!1&&this.element.on({"focusout.colorpicker":a.proxy(this.hide,this)})),this.component!==!1&&this.component.on({"click.colorpicker":a.proxy(this.show,this)}),this.input===!1&&this.component===!1&&this.element.on({"click.colorpicker":a.proxy(this.show,this)}),this.input!==!1&&this.component!==!1&&"color"===this.input.attr("type")&&this.input.on({"click.colorpicker":a.proxy(this.show,this),"focus.colorpicker":a.proxy(this.show,this)}),this.update(),a(a.proxy(function(){this.element.trigger("create")},this))};d.Color=b,d.prototype={constructor:d,destroy:function(){this.picker.remove(),this.element.removeData("colorpicker").off(".colorpicker"),this.input!==!1&&this.input.off(".colorpicker"),this.component!==!1&&this.component.off(".colorpicker"),this.element.removeClass("colorpicker-element"),this.element.trigger({type:"destroy"})},reposition:function(){if(this.options.inline!==!1||this.options.container)return!1;var a=this.container&&this.container[0]!==document.body?"position":"offset",b=this.component||this.element,c=b[a]();"right"===this.options.align&&(c.left-=this.picker.outerWidth()-b.outerWidth()),this.picker.css({top:c.top+b.outerHeight(),left:c.left})},show:function(b){return this.isDisabled()?!1:(this.picker.addClass("colorpicker-visible").removeClass("colorpicker-hidden"),this.reposition(),a(window).on("resize.colorpicker",a.proxy(this.reposition,this)),!b||this.hasInput()&&"color"!==this.input.attr("type")||b.stopPropagation&&b.preventDefault&&(b.stopPropagation(),b.preventDefault()),this.options.inline===!1&&a(window.document).on({"mousedown.colorpicker":a.proxy(this.hide,this)}),void this.element.trigger({type:"showPicker",color:this.color}))},hide:function(){this.picker.addClass("colorpicker-hidden").removeClass("colorpicker-visible"),a(window).off("resize.colorpicker",this.reposition),a(document).off({"mousedown.colorpicker":this.hide}),this.update(),this.element.trigger({type:"hidePicker",color:this.color})},updateData:function(a){return a=a||this.color.toString(this.format),this.element.data("color",a),a},updateInput:function(a){if(a=a||this.color.toString(this.format),this.input!==!1){if(this.options.colorSelectors){var c=new b(a,this.options.colorSelectors),d=c.toAlias();"undefined"!=typeof this.options.colorSelectors[d]&&(a=d)}this.input.prop("value",a)}return a},updatePicker:function(a){void 0!==a&&(this.color=new b(a,this.options.colorSelectors));var c=this.options.horizontal===!1?this.options.sliders:this.options.slidersHorz,d=this.picker.find("i");return 0!==d.length?(this.options.horizontal===!1?(c=this.options.sliders,d.eq(1).css("top",c.hue.maxTop*(1-this.color.value.h)).end().eq(2).css("top",c.alpha.maxTop*(1-this.color.value.a))):(c=this.options.slidersHorz,d.eq(1).css("left",c.hue.maxLeft*(1-this.color.value.h)).end().eq(2).css("left",c.alpha.maxLeft*(1-this.color.value.a))),d.eq(0).css({top:c.saturation.maxTop-this.color.value.b*c.saturation.maxTop,left:this.color.value.s*c.saturation.maxLeft}),this.picker.find(".colorpicker-saturation").css("backgroundColor",this.color.toHex(this.color.value.h,1,1,1)),this.picker.find(".colorpicker-alpha").css("backgroundColor",this.color.toHex()),this.picker.find(".colorpicker-color, .colorpicker-color div").css("backgroundColor",this.color.toString(this.format)),a):void 0},updateComponent:function(a){if(a=a||this.color.toString(this.format),this.component!==!1){var b=this.component.find("i").eq(0);b.length>0?b.css({backgroundColor:a}):this.component.css({backgroundColor:a})}return a},update:function(a){var b;return(this.getValue(!1)!==!1||a===!0)&&(b=this.updateComponent(),this.updateInput(b),this.updateData(b),this.updatePicker()),b},setValue:function(a){this.color=new b(a,this.options.colorSelectors),this.update(!0),this.element.trigger({type:"changeColor",color:this.color,value:a})},getValue:function(a){a=void 0===a?"#000000":a;var b;return b=this.hasInput()?this.input.val():this.element.data("color"),(void 0===b||""===b||null===b)&&(b=a),b},hasInput:function(){return this.input!==!1},isDisabled:function(){return this.hasInput()?this.input.prop("disabled")===!0:!1},disable:function(){return this.hasInput()?(this.input.prop("disabled",!0),this.element.trigger({type:"disable",color:this.color,value:this.getValue()}),!0):!1},enable:function(){return this.hasInput()?(this.input.prop("disabled",!1),this.element.trigger({type:"enable",color:this.color,value:this.getValue()}),!0):!1},currentSlider:null,mousePointer:{left:0,top:0},mousedown:function(b){b.pageX||b.pageY||!b.originalEvent||(b.pageX=b.originalEvent.touches[0].pageX,b.pageY=b.originalEvent.touches[0].pageY),b.stopPropagation(),b.preventDefault();var c=a(b.target),d=c.closest("div"),e=this.options.horizontal?this.options.slidersHorz:this.options.sliders;if(!d.is(".colorpicker")){if(d.is(".colorpicker-saturation"))this.currentSlider=a.extend({},e.saturation);else if(d.is(".colorpicker-hue"))this.currentSlider=a.extend({},e.hue);else{if(!d.is(".colorpicker-alpha"))return!1;this.currentSlider=a.extend({},e.alpha)}var f=d.offset();this.currentSlider.guide=d.find("i")[0].style,this.currentSlider.left=b.pageX-f.left,this.currentSlider.top=b.pageY-f.top,this.mousePointer={left:b.pageX,top:b.pageY},a(document).on({"mousemove.colorpicker":a.proxy(this.mousemove,this),"touchmove.colorpicker":a.proxy(this.mousemove,this),"mouseup.colorpicker":a.proxy(this.mouseup,this),"touchend.colorpicker":a.proxy(this.mouseup,this)}).trigger("mousemove")}return!1},mousemove:function(a){a.pageX||a.pageY||!a.originalEvent||(a.pageX=a.originalEvent.touches[0].pageX,a.pageY=a.originalEvent.touches[0].pageY),a.stopPropagation(),a.preventDefault();var b=Math.max(0,Math.min(this.currentSlider.maxLeft,this.currentSlider.left+((a.pageX||this.mousePointer.left)-this.mousePointer.left))),c=Math.max(0,Math.min(this.currentSlider.maxTop,this.currentSlider.top+((a.pageY||this.mousePointer.top)-this.mousePointer.top)));return this.currentSlider.guide.left=b+"px",this.currentSlider.guide.top=c+"px",this.currentSlider.callLeft&&this.color[this.currentSlider.callLeft].call(this.color,b/this.currentSlider.maxLeft),this.currentSlider.callTop&&this.color[this.currentSlider.callTop].call(this.color,c/this.currentSlider.maxTop),"setAlpha"===this.currentSlider.callTop&&this.options.format===!1&&(1!==this.color.value.a?(this.format="rgba",this.color.origFormat="rgba"):(this.format="hex",this.color.origFormat="hex")),this.update(!0),this.element.trigger({type:"changeColor",color:this.color}),!1},mouseup:function(b){return b.stopPropagation(),b.preventDefault(),a(document).off({"mousemove.colorpicker":this.mousemove,"touchmove.colorpicker":this.mousemove,"mouseup.colorpicker":this.mouseup,"touchend.colorpicker":this.mouseup}),!1},change:function(a){this.keyup(a)},keyup:function(a){38===a.keyCode?(this.color.value.a<1&&(this.color.value.a=Math.round(100*(this.color.value.a+.01))/100),this.update(!0)):40===a.keyCode?(this.color.value.a>0&&(this.color.value.a=Math.round(100*(this.color.value.a-.01))/100),this.update(!0)):(this.color=new b(this.input.val(),this.options.colorSelectors),this.color.origFormat&&this.options.format===!1&&(this.format=this.color.origFormat),this.getValue(!1)!==!1&&(this.updateData(),this.updateComponent(),this.updatePicker())),this.element.trigger({type:"changeColor",color:this.color,value:this.input.val()})}},a.colorpicker=d,a.fn.colorpicker=function(b){var c,e=arguments,f=this.each(function(){var f=a(this),g=f.data("colorpicker"),h="object"==typeof b?b:{};g||"string"==typeof b?"string"==typeof b&&(c=g[b].apply(g,Array.prototype.slice.call(e,1))):f.data("colorpicker",new d(this,h))});return"getValue"===b?c:f},a.fn.colorpicker.constructor=d});;
(function ($) {

  $.fn.rating = function () {

    var element;

    // A private function to highlight a star corresponding to a given value
    function _paintValue(ratingInput, value, active_icon, inactive_icon) {
      var selectedStar = $(ratingInput).find('[data-value="' + value + '"]');
      selectedStar.removeClass(inactive_icon).addClass(active_icon);
      selectedStar.prevAll('[data-value]').removeClass(inactive_icon).addClass(active_icon);
      selectedStar.nextAll('[data-value]').removeClass(active_icon).addClass(inactive_icon);
    }

    // A private function to remove the highlight for a selected rating
    function _clearValue(ratingInput, active_icon, inactive_icon) {
      var self = $(ratingInput);
      self.find('[data-value]').removeClass(active_icon).addClass(inactive_icon);
    }

    // A private function to change the actual value to the hidden field
    function _updateValue(input, val) {
      input.val(val).trigger('change');
      if (val === input.data('empty-value')) {
        input.siblings('.rating-clear').hide();
      } else {
        input.siblings('.rating-clear').show();
      }
    }


    // Iterate and transform all selected inputs
    for (element = this.length - 1; element >= 0; element--) {

      var el, i,
        originalInput = $(this[element]),
        max = originalInput.data('max') || 5,
        min = originalInput.data('min') || 0,
        def_val = originalInput.val() || 0,
        lib = originalInput.data('icon-lib') || 'glyphicon'
        active = originalInput.data('active-icon') || 'glyphicon-star',
        inactive = originalInput.data('inactive-icon') || 'glyphicon-star-empty',
        clearable = originalInput.data('clearable') || null,
        clearable_i = originalInput.data('clearable-icon') || 'glyphicon-remove',
        stars = '';

      // HTML element construction
      for (i = min; i <= max; i++) {
        // Create <max> empty stars
        if(i  <= def_val){
          stars += ['<i class="',lib, ' ', active, '" data-value="', i, '"></i>'].join('');
          }
        else{
            stars += ['<i class="',lib, ' ', inactive, '" data-value="', i, '"></i>'].join('')
            }
      }
      // Add a clear link if clearable option is set
      if (clearable) {
          stars += [
          ' <a class="rating-clear" style="display:none;" href="javascript:void">',
          '<span class="',lib,' ',clearable_i,'"></span> ',
          clearable,
          '</a>'].join('');
      }

      // Clone with data and events the original input to preserve any additional data and event bindings.
      var newInput = originalInput.clone(true)
        .addClass('hidden')
        .data('max', max)
        .data('min', min)
        .data('icon-lib', lib)
        .data('active-icon', active)
        .data('inactive-icon', inactive);

      // Rating widget is wrapped inside a div
      el = [
        '<div class="rating-input">',
        stars,
        '</div>'].join('');

      // Replace original inputs HTML with the new one
      if (originalInput.parents('.rating-input').length <= 0) {
        originalInput.replaceWith($(el).append(newInput));
      }

    }

    // Give live to the newly generated widgets
    $('.rating-input')
      // Highlight stars on hovering
      .on('mouseenter', '[data-value]', function () {
        var self = $(this);
         input = self.siblings('input');
        _paintValue(self.closest('.rating-input'), self.data('value'), input.data('active-icon'), input.data('inactive-icon'));
      })
      // View current value while mouse is out
      .on('mouseleave', '[data-value]', function () {
        var self = $(this),
          input = self.siblings('input'),
          val = input.val(),
          min = input.data('min'),
          max = input.data('max'),
          active = input.data('active-icon'),
          inactive = input.data('inactive-icon');
        if (val >= min && val <= max) {
          _paintValue(self.closest('.rating-input'), val, active, inactive);
        } else {
          _clearValue(self.closest('.rating-input'), active, inactive);
        }
      })
      // Set the selected value to the hidden field
      .on('click', '[data-value]', function (e) {
        var self = $(this),
          val = self.data('value'),
          input = self.siblings('input');
        _updateValue(input,val);
        e.preventDefault();
        return false;
      })
      // Remove value on clear
      .on('click', '.rating-clear', function (e) {
        var self = $(this),
          input = self.siblings('input'),
          active = input.data('active-icon'),
          inactive = input.data('inactive-icon');
        _updateValue(input, input.data('empty-value'));
        _clearValue(self.closest('.rating-input'), active, inactive);
        e.preventDefault();
        return false;
      })
      // Initialize view with default value
      .each(function () {
        var input = $(this).find('input'),
          val = input.val(),
          min = input.data('min'),
          max = input.data('max');
        if (val !== "" && +val >= min && +val <= max) {
          _paintValue(this, val);
          $(this).find('.rating-clear').show();
        }
        else {
          input.val(input.data('empty-value'));
          _clearValue(this);
        }
      });

  };

  // Auto apply conversion of number fields with class 'rating' into rating-fields
  $(function () {
    if ($('input.rating[type=number]').length > 0) {
      $('input.rating[type=number]').rating();
    }
  });

}(jQuery));
;
(function ($) {
    'use strict';
    window.Rock = window.Rock || {};
    Rock.controls = Rock.controls || {};

    Rock.controls.bootstrapButton = (function () {

        var exports = {
            showLoading: function (btn) {

                if (typeof (Page_ClientValidate) == 'function') {

                    if (Page_IsValid) {
                        // make sure page really is valid
                        Page_ClientValidate();
                    }
                }

                var $btn = $(btn);

                if (Page_IsValid) {
                    setTimeout(function () {
                        $btn.prop('disabled', true);
                        $btn.attr('disabled', 'disabled');
                        $btn.addClass('disabled');
                        $btn.html($btn.attr('data-loading-text'));
                    }, 0)
                }

                return true;
            }
        };

        return exports;
    }());
}(jQuery));;
(function ($) {
    'use strict';
    window.Rock = window.Rock || {};

    Rock.controls.charts = (function () {
        var exports = {

            ///
            /// handles putting chartData into a Line/Bar/Points chart
            ///
            plotChartData: function (chartData, chartOptions, plotSelector, yaxisLabelText, getSeriesPartitionNameUrl, combineValues) {
                
                var chartSeriesLookup = {};
                var chartSeriesList = [];

                var chartGoalPoints = {
                    label: yaxisLabelText + ' Goal',
                    chartData: [],
                    data: []
                }

                if (chartOptions.customSettings) {
                    chartGoalPoints.color = chartOptions.customSettings.goalSeriesColor;
                }

                // populate the chartMeasurePoints data array with data from the REST result
                for (var i = 0; i < chartData.length; i++) {
                    if (chartData[i].MetricValueType && chartData[i].MetricValueType == 1) {
                        // if the chartdata is marked as a Metric Goal Value Type, populate the chartGoalPoints
                        chartGoalPoints.data.push([chartData[i].DateTimeStamp, chartData[i].YValue]);
                        chartGoalPoints.chartData.push(chartData[i]);
                    }
                    else {
                        var lookupKey = chartData[i].MetricValuePartitionEntityIds;
                        if (!lookupKey || lookupKey == '') {
                            lookupKey = chartData[i].SeriesName;
                        }

                        if (!chartSeriesLookup[lookupKey]) {

                            // If SeriesName is specified, that can be the name of the series if MetricValuePartitionEntityIds is blank
                            var seriesName = chartData[i].SeriesName;

                            // if we aren't combining values, we'll have to lookup the series name based on MetricValuePartitionEntityIds
                            if (chartData[i].MetricValuePartitionEntityIds && chartData[i].MetricValuePartitionEntityIds != '' && !combineValues)
                            {
                                // MetricValuePartitionEntityIds is not blank so get the seriesName from the getSeriesPartitionNameUrl
                                if (getSeriesPartitionNameUrl) {
                                    $.ajax({
                                        url: getSeriesPartitionNameUrl + chartData[i].MetricValuePartitionEntityIds,
                                        async: false
                                    })
                                    .done(function (data) {
                                        seriesName = data;
                                    });
                                }
                            }

                            // either either seriesName, yaxisLabelText or just 'value' if the seriesname isn't defined
                            seriesName = seriesName || yaxisLabelText || 'value';

                            chartSeriesLookup[lookupKey] = {
                                label: seriesName,
                                chartData: [],
                                data: []
                            };
                        }

                        chartSeriesLookup[lookupKey].data.push([chartData[i].DateTimeStamp, chartData[i].YValue]);
                        chartSeriesLookup[lookupKey].chartData.push(chartData[i]);
                    }
                }

                // setup the series list (goal points last, if they exist)
                for (var chartSeriesKey in chartSeriesLookup) {
                    var chartMeasurePoints = chartSeriesLookup[chartSeriesKey];
                    if (chartMeasurePoints.data.length) {
                        chartSeriesList.push(chartMeasurePoints);
                    }
                }

                if (combineValues && chartSeriesList.length != 1) {

                    var combinedDataLookup = {};
                    var chartMeasurePoints = null;

                    for (var chartMeasurePointsId in chartSeriesList) {

                        chartMeasurePoints = chartSeriesList[chartMeasurePointsId];

                        $.each(chartMeasurePoints.data, function (indexInArray, dataPair) {
                            var dateTimeIndex = dataPair[0];
                            var combinedItem = combinedDataLookup[dateTimeIndex];
                            if (combinedItem) {
                                // sum the YValue of the .data
                                combinedItem.chartData.YValue += chartMeasurePoints.chartData[indexInArray].YValue;
                                combinedItem.data[1] += dataPair[1];
                            }
                            else {
                                combinedDataLookup[dateTimeIndex] = {
                                    chartData: chartMeasurePoints.chartData[indexInArray],
                                    data: dataPair
                                };
                            }
                        });
                    }

                    var combinedData = [];
                    var combinedChartData = [];

                    for (var dataLookupId in combinedDataLookup) {
                        combinedData.push(combinedDataLookup[dataLookupId].data);
                        combinedChartData.push(combinedDataLookup[dataLookupId].chartData);
                    }

                    chartSeriesList = [];

                    // sort data after combining
                    combinedChartData.sort(function (item1, item2) { return item2.DateTimeStamp - item1.DateTimeStamp });
                    combinedData.sort(function (item1, item2) { return item2[0] - item1[0]; });

                    var chartCombinedMeasurePoints = {
                        label: yaxisLabelText + ' Total',
                        chartData: combinedChartData,
                        data: combinedData
                    };


                    chartSeriesList.push(chartCombinedMeasurePoints);
                }

                if (chartGoalPoints.data.length) {
                    chartSeriesList.push(chartGoalPoints);
                }

                // plot the chart
                if (chartSeriesList.length > 0) {
                    $.plot(plotSelector, chartSeriesList, chartOptions);
                }
                else {
                    $(plotSelector).html('<div class="alert alert-info">No Data Found</div>');
                }
            },

            ///
            /// handles putting chart data into a piechart
            ///
            plotPieChartData: function (chartData, chartOptions, plotSelector, getSeriesPartitionNameUrl) {
                var pieData = [];

                // populate the chartMeasurePoints data array with data from the REST result for pie data
                for (var i = 0; i < chartData.length; i++) {

                    pieData.push({
                        label: chartData[i].MetricTitle,
                        data: chartData[i].YValueTotal,
                        chartData: [chartData[i]]
                    });
                }

                if (pieData.length > 0) {
                    // plot the pie chart
                    $.plot(plotSelector, pieData, chartOptions);
                }
                else {
                    $(plotSelector).html('<div class="alert alert-info">No Data Found</div>');
                }
            },

            ///
            /// handles putting chart data into a bar chart
            ///
            plotBarChartData: function (chartData, chartOptions, plotSelector, getSeriesPartitionNameUrl) {
                var barData = [];
                var combinedData = {};
                var seriesLabels = [];
                var seriesNameLookup = {};

                // populate the chartMeasurePoints data array with data from the REST result for bar chart data
                for (var i = 0; i < chartData.length; i++) {

                    var seriesCategory = chartData[i].SeriesName;
                    if (chartData[i].MetricValuePartitionEntityIds)
                    {
                        if (!seriesNameLookup[chartData[i].MetricValuePartitionEntityIds])
                        {
                            // MetricValuePartitionEntityIds is not blank so get the seriesName from the getSeriesPartitionNameUrl
                            if (getSeriesPartitionNameUrl) {
                                $.ajax({
                                    url: getSeriesPartitionNameUrl + chartData[i].MetricValuePartitionEntityIds,
                                    async: false
                                })
                                .done(function (data) {
                                    seriesNameLookup[chartData[i].MetricValuePartitionEntityIds] = data;
                                });
                            }
                        }

                        seriesCategory = seriesNameLookup[chartData[i].MetricValuePartitionEntityIds] || seriesCategory;
                    }

                    if (!combinedData[seriesCategory])
                    {
                        combinedData[seriesCategory] = 0;
                    }

                    combinedData[seriesCategory] += chartData[i].YValue;
                }

                var seriesId = 0;
                for (var combinedDataKey in combinedData) {

                    barData.push([combinedDataKey, combinedData[combinedDataKey]]);
                    seriesId++;
                    seriesLabels.push(combinedDataKey);
                }

                seriesLabels.push(seriesCategory);

                if (barData.length > 0) {
                    // plot the bar chart
                    chartOptions.series.chartData = chartData;
                    chartOptions.series.labels = seriesLabels;
                    $.plot(plotSelector, [barData], chartOptions);
                }
                else {
                    $(plotSelector).html('<div class="alert alert-info">No Data Found</div>');
                }
            },

            ///
            /// attaches a bootstrap style tooltip to the 'plothover' of a chart
            ///
            bindTooltip: function (plotContainerId, tooltipFormatter) {
                // setup of bootstrap tooltip which we'll show on the plothover event
                var toolTipId = 'tooltip_' + plotContainerId;
                var chartContainer = '#' + plotContainerId;

                $("<div id=" + toolTipId + " class='tooltip top'><div class='tooltip-inner'></div><div class='tooltip-arrow'></div></div>").css({
                    position: 'absolute',
                    display: 'none',
                }).appendTo('body');

                var $toolTip = $('#' + toolTipId);

                $(chartContainer).bind('plothover', function (event, pos, item) {

                    if (item) {

                        var tooltipText = "";

                        // if a tooltipFormatter is specified, use that
                        if (tooltipFormatter) {
                            tooltipText = tooltipFormatter(item);
                        }
                        else {
                            if (item.series.chartData) {
                                if (item.series.chartData[item.dataIndex].DateTimeStamp) {
                                    tooltipText = new Date(item.series.chartData[item.dataIndex].DateTimeStamp).toLocaleDateString();
                                };

                                if (item.series.chartData[item.dataIndex].StartDateTimeStamp) {
                                    tooltipText = new Date(item.series.chartData[item.dataIndex].StartDateTimeStamp).toLocaleDateString();
                                }

                                if (item.series.chartData[item.dataIndex].EndDateTimeStamp) {
                                    tooltipText += " to " + new Date(item.series.chartData[item.dataIndex].EndDateTimeStamp).toLocaleDateString();
                                }
                            }

                            if (tooltipText) {
                                tooltipText += '<br />';
                            }

                            if (item.series.label) {
                                tooltipText += item.series.label;
                            }

                            if (item.series.chartData) {
                                var pointValue = item.series.chartData[item.dataIndex].YValue || item.series.chartData[item.dataIndex].YValueTotal || '';

                                tooltipText += ': ' + pointValue;

                                if (item.series.chartData[item.dataIndex].Note) {
                                    tooltipText += '<br />' + item.series.chartData[item.dataIndex].Note;
                                }
                            }
                        }

                        $toolTip.find('.tooltip-inner').html(tooltipText);
                        
                        var tipTop = pos.pageY - $toolTip.height() - 10;

                        var windowWidth = $(window).width();
                        var tooltipWidth = $toolTip.width();
                        var tipLeft = pos.pageX - ( tooltipWidth / 2);
                        if (tipLeft + tooltipWidth + 10 >= windowWidth) {
                            tipLeft = tipLeft - (tooltipWidth / 2);
                            $toolTip.removeClass("top");
                            $toolTip.addClass("left");
                        }
                        else {
                            $toolTip.removeClass("left");
                            $toolTip.addClass("top");
                        }

                        $toolTip.css({ top: tipTop, left: tipLeft, opacity: 1 });
                        $toolTip.show();
                    }
                    else {
                        $toolTip.hide();
                    }
                });

            }
        };

        return exports;
    }());
}(jQuery));


;
(function ($) {
    'use strict';
    window.Rock = window.Rock || {};
    Rock.controls = Rock.controls || {};

    Rock.controls.datePicker = (function () {
        var exports = {
            initialize: function (options) {
                if (!options.id) {
                    throw 'id is required';
                }
                var dateFormat = 'mm/dd/yyyy';
                if (options.format) {
                    dateFormat = options.format;
                }

                var $textBox = $('#' + options.id);

                var $datePickerContainer = $textBox.closest('.js-date-picker-container');
                var $datePickerInputGroup = $textBox.closest('.input-group.js-date-picker');

                // uses https://github.com/eternicode/bootstrap-datepicker
                $datePickerInputGroup.datepicker({
                    format: dateFormat,
                    autoclose: true,
                    todayBtn: true,
                    startView: options.startView || 'month',
                    todayHighlight: options.todayHighlight || true
                });

                // if the guest clicks the addon select all the text in the input
                $datePickerInputGroup.find('.input-group-addon').on('click', function () {
                    $(this).siblings('.form-control').select();
                });

                $datePickerContainer.find('.js-current-date-checkbox').on('click', function (a,b,c) {
                    var $dateOffsetBox = $datePickerContainer.find('.js-current-date-offset');
                    var $dateOffsetlabel = $("label[for='" + $dateOffsetBox.attr('id') + "']")
                    if ($(this).is(':checked')) {
                        $dateOffsetlabel.show();
                        $dateOffsetBox.show();
                        $textBox.val('');
                        $textBox.prop('disabled', true);
                        $textBox.addClass('aspNetDisabled');

                    } else {
                        $dateOffsetlabel.hide();
                        $dateOffsetBox.hide();
                        $textBox.prop('disabled', false);
                        $textBox.removeClass('aspNetDisabled');
                    }
                });
            }
        };

        return exports;
    }());
}(jQuery));;
(function ($) {
    'use strict';
    window.Rock = window.Rock || {};
    Rock.controls = Rock.controls || {};

    Rock.controls.dateTimePicker = (function () {
        var exports = {
            initialize: function (options) {
                if (!options.id) {
                    throw 'id is required';
                }
                var dateFormat = 'mm/dd/yyyy';
                if (options.format) {
                    dateFormat = options.format;
                }

                var $dp = $('#' + options.id + " .input-group.date");

                // uses https://github.com/eternicode/bootstrap-datepicker
                $dp.datepicker({
                    format: dateFormat,
                    autoclose: true,
                    todayBtn: true,
                    startView: options.startView || 'month',
                    todayHighlight: options.todayHighlight || true
                });
                
                // if the guest clicks the addon select all the text in the input
                $dp.find('.input-group-addon').on('click', function () {
                    $(this).siblings('.form-control').select();
                });

                var $tp = $('#' + options.id + " .js-datetime-time");
                if ($tp) {
                    var $tpid = $tp.attr('id');
                    if ($tpid) {
                        Rock.controls.timePicker.initialize({
                            id: $tpid
                        });
                    }
                }

                var $dateTimePickerContainer = $dp.closest('.js-datetime-picker-container');
                
                $dateTimePickerContainer.find('.js-current-datetime-checkbox').on('click', function (a, b, c) {
                    var $dateTimeOffsetBox = $dateTimePickerContainer.find('.js-current-datetime-offset');
                    var $dateOffsetlabel = $("label[for='" + $dateTimeOffsetBox.attr('id') + "']")
                    if ($(this).is(':checked')) {
                        $dateOffsetlabel.removeClass('aspNetDisabled');
                        $dateTimeOffsetBox.prop('disabled', false);
                        $dateTimeOffsetBox.removeClass('aspNetDisabled');
                        $dp.val('');
                        $dp.prop('disabled', true);
                        $dp.addClass('aspNetDisabled');
                        $tp.val('');
                        $tp.prop('disabled', true);
                        $tp.addClass('aspNetDisabled');
                    } else {
                        $dateOffsetlabel.addClass('aspNetDisabled');
                        $dateTimeOffsetBox.prop('disabled', true);
                        $dateTimeOffsetBox.addClass('aspNetDisabled');
                        $dateTimeOffsetBox.val('');
                        $dp.prop('disabled', false);
                        $dp.removeClass('aspNetDisabled');
                        $tp.prop('disabled', false);
                        $tp.removeClass('aspNetDisabled');
                    }
                });
            }
        };

        return exports;
    }());
}(jQuery));;
(function ($) {
    'use strict';
    window.Rock = window.Rock || {};
    Rock.controls = Rock.controls || {};

    Rock.controls.fileUploader = (function () {
        var _configure = function (options) {
            options.isBinaryFile = options.isBinaryFile || 'T';
            options.uploadUrl = options.uploadUrl || 'FileUploader.ashx';

            var wsUrl = Rock.settings.get('baseUrl')
                        + options.uploadUrl + '?'
                        + 'isBinaryFile=' + options.isBinaryFile;

            if (options.isBinaryFile == 'T') {
                wsUrl += '&fileId=' + options.fileId
                    + '&fileTypeGuid=' + options.fileTypeGuid;
            }
            else {
                // note rootFolder is encrypted to prevent direct access to filesystem via the URL
                wsUrl += '&rootFolder=' + (encodeURIComponent(options.rootFolder) || '');
            }

            // uses https://github.com/blueimp/jQuery-File-Upload
            $('#' + options.controlId).fileupload({
                url: wsUrl,
                dataType: 'json',
                dropZone: $('#' + options.controlId).closest('.fileupload-dropzone'),
                autoUpload: true,
                submit: options.submitFunction,
                start: function (e, data) {
                    var $el = $('#' + options.controlId).closest('.fileupload-group');
                    $el.find('.js-upload-progress').rockFadeIn();
                },
                progressall: function (e, data) {
                    try {
                        if (data.total > 0) {
                            var $el = $('#' + options.controlId).closest('.fileupload-group');
                            var $progressPercent = $el.find('.progress-percent');
                            if (!$progressPercent.length) {
                                return;
                            }

                            var percent = (data.loaded * 100 / data.total).toFixed(0);
                            if (percent > 1 && percent < 99) {
                                $progressPercent.text(percent + "%");
                            }
                            else {
                                $progressPercent.text("uploading");
                            }
                        }
                    }
                    catch (ex) {
                        // ignore if any exception occurs
                    }
                },
                stop: function (e) {
                    var $el = $('#' + options.controlId).closest('.fileupload-group');
                    $el.find('.js-upload-progress').hide();
                    $el.find('.fileupload-dropzone').show();
                },
                done: function (e, data) {
                    var $el = $('#' + options.aFileName);

                    if ((options.isBinaryFile || 'T') == 'F') {
                        $('#' + options.hfFileId).val(data.response().result.FileName);
                    }
                    else {
                        $('#' + options.hfFileId).val(data.response().result.Id);
                    }

                    var getFileUrl = Rock.settings.get('baseUrl')
                        + 'GetFile.ashx?'
                        + 'isBinaryFile=' + (options.isBinaryFile || 'T')
                        // note rootFolder is encrypted to prevent direct access to filesystem via the URL
                        + '&rootFolder=' + (encodeURIComponent(options.rootFolder) || '')
                        + '&id=' + data.response().result.Id
                        + '&fileName=' + data.response().result.FileName;

                    $el.text(data.response().result.FileName).attr('href', getFileUrl);
                    $('#' + options.aRemove).show();
                    if (options.postbackScript) {
                        window.location = "javascript:" +  options.postbackScript;
                    }

                    if (options.doneFunction) {
                        options.doneFunction(e, data);
                    }
                },
                fail: function (e, data) {
                    var $el = $('#' + options.controlId).closest('.fileupload-group');
                    $el.siblings('.js-rockupload-alert').remove();
                    var $warning = $('<div class="alert alert-warning alert-dismissable js-rockupload-alert"/>');

                    var msg = "unable to upload";
                    if (data.response().jqXHR && data.response().jqXHR.status == 406) {
                        msg = "file type not allowed";
                    } else if (data.response().jqXHR && data.response().jqXHR.responseText) {
                        msg = data.response().jqXHR.responseText;
                    }

                    if (options.maxUploadBytes && data.total) {
                        if (data.total >= options.maxUploadBytes) {
                            msg = "file size is limited to " + (options.maxUploadBytes / 1024 / 1024) + "MB";
                        }
                    }

                    $warning.append('<button type="button" class="close" data-dismiss="alert" aria-hidden="true">&times;</button>')
                        .append('<strong><i class="fa fa-exclamation-triangle"></i> Warning </strong>')
                        .append(msg);
                    $warning.insertBefore($el);
                }
            });

            $('#' + options.aRemove).click(function () {
                $(this).hide();
                var $el = $('#' + options.aFileName);
                $el.attr('href', '#');
                $el.text('');
                $el.removeClass('file-exists');

                if (options.postbackRemovedScript) {
                    window.location = "javascript:" + options.postbackRemovedScript;
                } else {
                    $('#' + options.hfFileId).val('0');
                }

                return false;
            });
        },
        exports = {
            initialize: function (options) {
                if (!options.controlId) throw 'Control ID must be set.';
                _configure(options);
            }
        };

        return exports;
    }());
}(jQuery));;
(function ($) {
    'use strict';
    window.Rock = window.Rock || {};
    Rock.controls = Rock.controls || {};

    Rock.controls.followingsToggler = (function () {

        var exports = {
            // initialize a script that will set the following status via REST
            // entityTypeId is the EntityType, and entityId is the .Id for the associated entity
            // personId and personAliasId are the person that is doing the following/un-following
            initialize: function ($followingDiv, entityTypeId, entityId, personId, personAliasId) {
                $followingDiv.click(function () {
                    if ($followingDiv.hasClass('following')) {

                        $.ajax({
                            type: 'DELETE',
                            url: Rock.settings.get('baseUrl') + 'api/followings/' + entityTypeId + '/' + entityId + '/' + personId,
                            success: function (data, status, xhr) {
                                $followingDiv.removeClass('following');

                                // update the tooltip (if one was configured)
                                if ($followingDiv.attr("data-original-title")) {
                                    $followingDiv.attr("data-original-title", 'Click to follow');
                                }
                            },
                        });

                    } else {
                        var following = {
                            EntityTypeId: entityTypeId,
                            EntityId: entityId,
                            PersonAliasId: personAliasId
                        };

                        $.ajax({
                            type: 'POST',
                            contentType: 'application/json',
                            data: JSON.stringify(following),
                            url: Rock.settings.get('baseUrl') + 'api/followings',
                            statusCode: {
                                201: function () {
                                    $followingDiv.addClass('following');

                                    // update the tooltip (if one was configured)
                                    if ($followingDiv.attr("data-original-title")) {
                                        $followingDiv.attr("data-original-title", 'Currently following');
                                    }
                                }
                            }
                        });
                    }
                })
            }
        };

        return exports;
    }());
}(jQuery));;
(function ($) {
    'use strict';
    window.Rock = window.Rock || {};
    Rock.controls = Rock.controls || {};

    Rock.controls.geoPicker = (function () {

        var GeoPicker = function (options) {
            var obj = this;
            obj.controlId = options.controlId;
            obj.restUrl = options.restUrl;
            obj.path = options.path;
            obj.centerAddress = options.centerAddress;                     // used when nothing is on map
            obj.centerLatitude = options.centerLatitude || "33.590795";     // used when nothing is on map
            obj.centerLongitude = options.centerLongitude || "-112.126459"; // used when nothing is on map
            obj.drawingMode = options.drawingMode || "Polygon" || "Point"; // the available modes
            obj.strokeColor = options.strokeColor || "#0088cc";
            obj.fillColor = options.fillColor || "#0088cc";

            // An array of styles that controls the look of the Google Map
            // http://gmaps-samples-v3.googlecode.com/svn/trunk/styledmaps/wizard/index.html
            obj.styles = options.mapStyle;

            // This is used to temporarily store in case of user cancel.
            obj.pathTemp = null;

            // the selected polygon or point
            obj.selectedShape = null;

            // these are used to set the map's viewport boundary
            obj.minLat = null;
            obj.maxLat = null;
            obj.minLng = null;
            obj.maxLng = null;

            // our google Map
            obj.map = null;

            // an instance of the Google Maps drawing manager
            obj.drawingManager = null;

            // An array of styles that controls the look of the Google Map
            // http://gmaps-samples-v3.googlecode.com/svn/trunk/styledmaps/wizard/index.html
            //obj.styles = [
            //  {
            //      "stylers": [
            //        { "visibility": "simplified" },
            //        { "saturation": -100 }
            //      ]
            //  }, {
            //      "featureType": "road",
            //      "elementType": "labels",
            //      "stylers": [
            //        { "visibility": "on" }
            //      ]
            //  }, {
            //      "featureType": "poi",
            //      "stylers": [
            //        { "visibility": "off" }
            //      ]
            //  }, {
            //      "featureType": "landscape",
            //      "stylers": [
            //        { "visibility": "off" }
            //      ]
            //  }, {
            //      "featureType": "administrative.province",
            //      "stylers": [
            //        { "visibility": "on" }
            //      ]
            //  }, {
            //      "featureType": "administrative.locality",
            //      "stylers": [
            //        { "visibility": "on" }
            //      ]
            //  }
            //];

            /** 
            * Initializes the map viewport boundary coordinates.
            */
            this.initMinMaxLatLng = function () {
                obj.minLat = null;
                obj.maxLat = null;
                obj.minLng = null;
                obj.maxLng = null;
            }

            /**
            * Unselects the selected shape (if selected) and disables the delete button.
            */
            this.clearSelection = function () {
                if (obj.selectedShape) {
                    if (obj.drawingMode == "Polygon") {
                        obj.selectedShape.setEditable(false);
                    }
                    obj.selectedShape = null;
                }
                $('#gmnoprint-delete-button_' + obj.controlId).attr('disabled', '')
                $('#gmnoprint-delete-button_' + obj.controlId + ' .fa-times').css("color", "#aaa");
            }

            /**
            * Stores the given shape's path points into the path property as a
            * pipe (|) delimited list of lat,long coordinates.  This method also
            * re-enables the delete button so that the polygon can be deleted.
            */
            this.setSelection = function (shape, type) {
                obj.clearSelection();

                // enable delete button
                var $deleteButton = $('#gmnoprint-delete-button_' + obj.controlId);
                $('#gmnoprint-delete-button_' + obj.controlId).removeAttr('disabled');
                $('#gmnoprint-delete-button_' + obj.controlId + ' .fa-times').css("color", "");

                obj.selectedShape = shape;
                
                if (type == "polygon") {
                    shape.setEditable(true);
                    var coordinates = new Array();
                    var vertices = shape.getPaths().getAt(0);
                    // Iterate over the vertices of the shape's path
                    for (var i = 0; i < vertices.length; i++) {
                        var xy = vertices.getAt(i);
                        coordinates[i] = xy.toUrlValue();
                    }

                    // if the last vertex is not already the first, then
                    // add the first vertex to the end of the path.
                    if (vertices.getAt(0).toUrlValue() != coordinates[coordinates.length - 1]) {
                        obj.path = coordinates.join('|') + '|' + vertices.getAt(0).toUrlValue();
                    }
                    else {
                        obj.path = coordinates.join('|');
                    }
                    //console.log(obj.path);
                }
                else if (type == "marker") {
                    obj.path = shape.getPosition().toUrlValue();
                }
            }

            /**
            * Delete the selected shape and enable the drawing controls
            * if they were deleted.  Also removes the polygon from the hidden variable.
            */
            this.deleteSelectedShape = function () {
                if (obj.selectedShape && confirm("Delete selected shape?")) {
                    obj.selectedShape.setMap(null);
                    obj.clearSelection();

                    // delete the path
                    obj.path = null;

                    // enable the drawing controls again
                    obj.drawingManager.setOptions({
                        drawingControlOptions: {
                            drawingModes: obj.getDrawingModes()
                        }
                    });
                }
            }

            /**
            * Returns the appropriate mode array for use with the map's DrawingManager
            * drawing control options.
            */
            this.getDrawingModes = function getDrawingModes() {

                if (obj.drawingMode == "Polygon") {
                    return [google.maps.drawing.OverlayType.POLYGON];
                }
                else if (obj.drawingMode == "Point") {
                    return [google.maps.drawing.OverlayType.MARKER];
                }
            }

            /**
            * Returns a marker image styled according to the stroke color.
            */
            this.getMarkerImage = function getMarkerImage() {

                return new google.maps.MarkerImage('//chart.googleapis.com/chart?chst=d_map_pin_letter&chld=%E2%80%A2|' + obj.strokeColor,
                    new google.maps.Size(21, 34),
                    new google.maps.Point(0, 0),
                    new google.maps.Point(10, 34));
            }

            /**
            * Returns a marker image shadow.
            */
            this.getMarkerImageShadow = function getMarkerImageShadow() {

                return new google.maps.MarkerImage('//chart.googleapis.com/chart?chst=d_map_pin_shadow',
                    new google.maps.Size(40, 37),
                    new google.maps.Point(0, 0),
                    new google.maps.Point(12, 35));
            }

            /**
            * Finds the point/polygon boundary and sets the map viewport to fit
            */
            this.fitBounds = function () {
                if (! obj.path) {
                    // if no path, then set the center using the options
                    var newLatLng = new google.maps.LatLng(
                        parseFloat(obj.centerLatitude),
                        parseFloat(obj.centerLongitude));
                    obj.map.setCenter(newLatLng);
                    return;
                }

                var coords = obj.path.split('|');
                var pathArray = new Array();
                // find the most southWest and northEast points of the path.
                for (var i = 0; i < coords.length ; i++) {
                    var latLng = coords[i].split(',');
                    var lat = parseFloat(latLng[0]);
                    var lng = parseFloat(latLng[1]);
                    // find the most southWest and northEast points of the path.
                    obj.findBounds(lat, lng);
                    pathArray.push(new google.maps.LatLng(lat, lng));
                }

                // Set the viewport to contain the given bounds.
                var southWest = new google.maps.LatLng(obj.minLat, obj.minLng);
                var northEast = new google.maps.LatLng(obj.maxLat, obj.maxLng);
                var bounds = new google.maps.LatLngBounds(southWest, northEast);
                obj.map.fitBounds(bounds);

                if (obj.drawingMode == "Point") {
                    obj.map.setZoom(16);
                }
            }

            /**
            * Utility method to determine the most SouthWestern
            * and NorthEastern lat and long.
            */
            this.findBounds = function (lat, lng) {
                if (!obj.minLat || lat < obj.minLat) {
                    obj.minLat = lat;
                }
                if (!obj.maxLat || lat > obj.maxLat) {
                    obj.maxLat = lat;
                }
                if (!obj.minLng || lng < obj.minLng) {
                    obj.minLng = lng;
                }
                if (!obj.maxLng || lng > obj.maxLng) {
                    obj.maxLng = lng;
                }
                //console.log( 'min/max lat: ' + obj.minLat + '/' + obj.maxLat + ' min/max long: ' + obj.minLng + '/' + obj.minLng );
            }

            /**
            * Disables the drawing manager so they cannot add anything to the map.
            */
            this.disableDrawingManager = function () {
                // Switch back to non-drawing mode after drawing a shape.
                if (!obj.drawingManager) {
                    return;
                }

                obj.drawingManager.setDrawingMode(null);

                // disable the drawing controls so we only get one polygon
                // and we'll add it back on deleting the existing polygon.
                obj.drawingManager.setOptions({
                    drawingControlOptions: {
                        drawingModes: [
                        ]
                    }
                });
            }

            /**
            * Takes the path data stored in the path and plots it on the map.
            */
            this.plotPath = function (map) {
                obj.initMinMaxLatLng();
                // only try this if we have a path
                if (obj.path) {
                    //console.log("found an obj.path to plot: " + obj.path);

                    var coords = obj.path.split('|');
                    var pathArray = new Array();
                    // put the polygon coordinates into a path array
                    for (var i = 0; i < coords.length ; i++) {
                        var latLng = coords[i].split(',');
                        var lat = parseFloat(latLng[0]);
                        var lng = parseFloat(latLng[1]);
                        pathArray.push(new google.maps.LatLng(lat, lng));
                    }

                    // reverse geocode the first point to an address and display.
                    var $label = $('#selectedGeographyLabel_' + this.controlId);
                    obj.toAddress(pathArray[0], $label);

                    if (coords.length > 0) {
                        var polygon;

                        if (obj.drawingMode == "Polygon") {

                            var polygon = new google.maps.Polygon({
                                path: pathArray,
                                clickable: true,
                                editable: true,
                                strokeColor: obj.strokeColor,
                                fillColor: obj.fillColor,
                                strokeWeight: 2
                            });
                            polygon.setMap(map);

                            // Select the polygon
                            obj.setSelection(polygon, google.maps.drawing.OverlayType.POLYGON);

                            // Disable the drawing manager
                            obj.disableDrawingManager();

                            // add listener for moving polygon points.
                            google.maps.event.addListener(polygon.getPath(), 'set_at', function (e) {
                                obj.setSelection(polygon, google.maps.drawing.OverlayType.POLYGON);
                            });

                            // add listener for adding new points.
                            google.maps.event.addListener(polygon.getPath(), 'insert_at', function (e) {
                                obj.setSelection(polygon, google.maps.drawing.OverlayType.POLYGON);
                            });

                            //google.maps.event.addListener(polygon, 'mouseout', function (e) {
                            //    obj.setSelection(polygon, google.maps.drawing.OverlayType.POLYGON);
                            //});

                            // Add an event listener to implement right-click to delete node
                            google.maps.event.addListener(polygon, 'rightclick', function (ev) {
                                if (ev.vertex != null) {
                                    polygon.getPath().removeAt(ev.vertex);
                                }
                                obj.setSelection(polygon, google.maps.drawing.OverlayType.POLYGON);
                            });

                            // add listener for "selecting" the polygon
                            // because that's where we stuff the coordinates into the hidden variable
                            google.maps.event.addListener(polygon, 'click', function () {
                                obj.setSelection(polygon, google.maps.drawing.OverlayType.POLYGON);
                            });
                        }
                        else if (obj.drawingMode == "Point") {

                            var point = new google.maps.Marker({
                                position: pathArray[0],
                                map: map,
                                clickable: true,
                                icon: obj.getMarkerImage(),
                                shadow: obj.getMarkerImageShadow()
                            });

                            // Select the point
                            obj.setSelection(point, google.maps.drawing.OverlayType.MARKER);

                            // Disable the drawing manager
                            obj.disableDrawingManager();

                            // add listener for "selecting" the point
                            // because that's where we stuff the coordinates into the hidden variable
                            google.maps.event.addListener(point, 'click', function () {
                                obj.setSelection(point, google.maps.drawing.OverlayType.MARKER);
                            });
                        }
                    }
                }
            }

            /**
            * Take the given lat and long and try to reverse-geocode to an Address
            * then stuff that address as the value of the given element.
            */
            this.toAddress = function (latlng, $labelElement) {
                // only try if we have a valid latlng
                if (!latlng || isNaN(latlng.lat()) || isNaN(latlng.lng())) {
                    $labelElement.text('');
                    return;
                }
                var geocoder = new google.maps.Geocoder();
                geocoder = geocoder.geocode({ 'latLng': latlng }, function (results, status) {
                    if (status == google.maps.GeocoderStatus.OK) {
                        if (results[0]) {
                            $labelElement.text('near ' + results[0].formatted_address);
                        }
                    }
                    else
                    {
                        $labelElement.html('<i>selected</i>');
                        console.log('Geocoder failed due to: ' + status);
                    }
                });
            }

            /**
            * Geocode an address to a latLng and center the map on that point.
            */
            this.centerMapOnAddress = function () {
                var self = this;
                // only try if a centerAddress is set
                if (!obj.centerAddress) {
                    return;
                }

                var geocoder = new google.maps.Geocoder();

                geocoder.geocode({ 'address': obj.centerAddress }, function (results, status) {
                    if (status == google.maps.GeocoderStatus.OK) {
                        self.map.setCenter(results[0].geometry.location);
                    } else {
                        console.log('Geocode was not successful for the following reason: ' + status);
                    }
                });
            }

            /**
            * Return a latLng for the "first point" of the selected map.
            */
            this.firstPoint = function () {
                if (obj.path) {
                    var coords = obj.path.split('|');
                    if (coords) {
                        var latLng = coords[0].split(',');
                        var lat = parseFloat(latLng[0]);
                        var lng = parseFloat(latLng[1]);
                        return new google.maps.LatLng(lat, lng);
                    }
                }
            }

        }; // sorta end class

        /**
        * initialize our event handlers for the button clicks we're going to be handling.
        */
        GeoPicker.prototype.initializeEventHandlers = function () {
            var controlId = this.controlId,
                $control = $('#' + this.controlId),
                $hiddenField = $('#hfGeoPath_' + this.controlId),
                restUrl = this.restUrl;
            var self = this;

            /**
            * Toggle the picker on and off when the control's link is clicked.
            */
            $('#' + controlId + ' a.picker-label').click(function (e) {
                e.preventDefault();
                var $control = $('#' + controlId)
                $control.find('.picker-menu').first().toggle(function () {
                    Rock.dialogs.updateModalScrollBar(controlId);
                });

                if ( $control.find('.picker-menu').first().is(":visible") ) {
                    google.maps.event.trigger(self.map, "resize");
                    // now we can safely fit the map to any polygon boundary
                    self.fitBounds();

                    // Scroll down so you can see the done/cancel buttons
                    $("html,body").animate({
                        scrollTop: $control.offset().top
                    }, 1000);
                }
            });

            /**
            * Hide the expand button if we are in a modal
            */
            if ($control.closest('.modal').length) {
                $('#btnExpandToggle_' + controlId).hide();
            }

            /**
            * Handle the toggle expand fullscreen button click.
            */
            $('#btnExpandToggle_' + controlId).click(function () {

                var $myElement = $('#geoPicker_' + self.controlId);

                var isExpaned = $myElement.data("fullscreen");

                $(this).children('i').toggleClass("fa-expand", isExpaned);
                $(this).children('i').toggleClass("fa-compress", ! isExpaned);

                // Shrink to regular size
                if ( isExpaned ) {
                    $myElement.data("fullscreen", false);
                    
                    $(this).closest('.picker-menu').css({
                        position: 'absolute',
                        top: 0,
                        left: 0,
                        height: '',
                        width: 520
                    });
                    // resize the map
                    $myElement.css({
                        height: 300,
                        width: 500
                    });

                    // move the delete button
                    $('#gmnoprint-delete-button_' + self.controlId).css({
                        left: '105px',
                        top: '40',
                    });

                }
                else {

                    // Expand to fullscreen

                    $myElement.data("fullscreen", true);
                    // resize the container
                    $(this).closest('.picker-menu').css({
                        position: 'fixed',
                        top: 0,
                        left: 0,
                        height: '100%',
                        width: '100%'
                    });

                    // resize the map
                    $myElement.css({
                        height: '85%',
                        width: '100%'
                    });

                    // move the delete button
                    $('#gmnoprint-delete-button_' + self.controlId).css({
                        left: '160px',
                        top: '40',
                    });
                }

                // tell the map to resize/redraw
                google.maps.event.trigger(self.map, 'resize');
                self.fitBounds();

                Rock.dialogs.updateModalScrollBar(self.controlId);

            });

            /**
            * Handle the Cancel button click by hiding the overlay.
            */
            $('#btnCancel_' + controlId).click(function () {
                $(this).closest('.picker-menu').slideUp(function () {
                    Rock.dialogs.updateModalScrollBar(controlId);
                });

                self.path = self.pathTemp;

                if ( self.selectedShape ) {
                    self.selectedShape.setMap(null);
                    self.clearSelection();

                    // enable the drawing controls again
                    self.drawingManager.setOptions({
                        drawingControlOptions: {
                            drawingModes: self.getDrawingModes()
                        }
                    });
                }
                self.plotPath(self.map);
            });

            // have the X appear on hover if something is selected
            if ($hiddenField.val() && $hiddenField.val() !== '0') {
                $control.find('.picker-select-none').addClass('rollover-item');
                $control.find('.picker-select-none').show();
            }

            /**
            * Handle the Select button click by stuffing the RockGoogleGeoPicker's path value into the hidden field. 
            */
            $('#btnSelect_' + controlId).click(function () {
                var geoInput = $('#' + controlId).find('input:checked'),
                    selectedValue = self.path,
                    selectedGeographyLabel = $('#selectedGeographyLabel_' + controlId);

                //console.log('storing coordinates into hf (' + '#hfGeoPath_' + self.controlId + ') self.path:' + self.path);
                $hiddenField.val(self.path);

                // have the X appear on hover. something is selected
                $control.find('.picker-select-none').addClass('rollover-item');
                $control.find('.picker-select-none').show();

                selectedGeographyLabel.val(selectedValue);
                self.toAddress( self.firstPoint(), selectedGeographyLabel);

                //clear out any old map positioning
                self.initMinMaxLatLng();

                $(this).closest('.picker-menu').slideUp(function () {
                    Rock.dialogs.updateModalScrollBar(controlId);
                });
            });


            /**
            * Clear the selection when X is clicked
            */
            $control.find('.picker-select-none').click(function (e) {
                e.stopImmediatePropagation();
                var selectedGeographyLabel = $('#selectedGeographyLabel_' + controlId);
                $hiddenField.val("");

                // don't have the X appear on hover. nothing is selected
                $control.find('.picker-select-none').removeClass('rollover-item');
                $control.find('.picker-select-none').hide();

                selectedGeographyLabel.val("");
                self.toAddress(null, selectedGeographyLabel);

                //clear out any old map positioning
                self.initMinMaxLatLng();

                return false;
            });
        };

        /**
        * Initialize the GeoPicker.
        */
        GeoPicker.prototype.initialize = function () {
            var self = this;
            var $myElement = $('#geoPicker_' + self.controlId);
            var $hiddenField = $('#hfGeoPath_' + this.controlId);
            var deleteButtonId = 'gmnoprint-delete-button_' + self.controlId;

            // Pull anything in the hidden field onto this object's path
            self.path = $hiddenField.val();

            // store path into pathTemp in case of user cancel.
            self.pathTemp = self.path;

            // Create a new StyledMapType object, passing it the array of styles,
            // as well as the name to be displayed on the map type control.
            var styledMap = new google.maps.StyledMapType(self.styles, { name: "Styled Map" });

            // WARNING: I though about removing the "center:" from the options here but then the
            // map's controls were different and then our delete button was out of alignment.
            var mapOptions = {
                center: new google.maps.LatLng(
                        parseFloat(self.centerLatitude),
                        parseFloat(self.centerLongitude)),
                zoom: 13,
                streetViewControl: false,
                mapTypeControlOptions: {
                    mapTypeIds: [google.maps.MapTypeId.ROADMAP, 'map_style']
                }
            };
            // center the map on the configured address
            self.centerMapOnAddress();

            self.map = new google.maps.Map(document.getElementById('geoPicker_' + self.controlId), mapOptions);
            //console.log("adding map to element( " + 'geoPicker_' + self.controlId + " )");

            //Associate the styled map with the MapTypeId and set it to display.
            self.map.mapTypes.set('map_style', styledMap);
            self.map.setMapTypeId('map_style');

            // If we have coordinates we should plot them here...
            self.plotPath(self.map);
            
            // Set up the Drawing Manager for creating polygons, circles, etc.
            self.drawingManager = new google.maps.drawing.DrawingManager({
                drawingControl: true,
                drawingControlOptions: {
                    drawingModes: self.getDrawingModes()
                },
                polygonOptions: {
                    editable: true,
                    strokeColor: self.strokeColor,
                    fillColor: self.fillColor,
                    strokeWeight: 2
                },
                markerOptions: {
                    icon: self.getMarkerImage(),
                    shadow: self.getMarkerImageShadow()
                }
            });
            
            self.drawingManager.setMap(self.map);

            // but disable the drawing manager if we already have a point/polygon selected:
            if (self.path) {
                self.disableDrawingManager();
            }

            // Handle when the polygon shape drawing is "complete"
            google.maps.event.addListener(self.drawingManager, 'overlaycomplete', function (e) {
                if (e.type == google.maps.drawing.OverlayType.POLYGON || e.type == google.maps.drawing.OverlayType.MARKER ) {

                    // Disable the drawing manager once they've drawn an overlay.
                    self.disableDrawingManager();

                    // Add an event listener that selects the newly-drawn shape when the user
                    // mouses down on it.
                    var newShape = e.overlay;
                    newShape.type = e.type;
                    google.maps.event.addListener(newShape, 'click', function () {
                        self.setSelection(newShape, e.type);
                    });
                    self.setSelection(newShape, e.type);

                    // Add an event listener to implement right-click to delete node
                    google.maps.event.addListener(newShape, 'rightclick', function (ev) {
                        if (ev.vertex != null) {
                            newShape.getPath().removeAt(ev.vertex);
                        }
                        obj.setSelection(newShape, google.maps.drawing.OverlayType.POLYGON);
                    });
                }
            });

            // Clear the current selection when the drawing mode is changed, or when the
            // map is clicked.
            google.maps.event.addListener(self.drawingManager, 'drawingmode_changed', self.clearSelection);
            google.maps.event.addListener(self.map, 'click', self.clearSelection);

            // Move our custom delete button into place once the map is idle.
            // as per http://stackoverflow.com/questions/832692/how-to-check-if-google-maps-is-fully-loaded
            google.maps.event.addListenerOnce(self.map, 'idle', function () {
                // move the custom delete button to the second to last item in the gmnoprint list
                //$('#' + deleteButtonId).insertAfter($myElement.find('div.gmnoprint:nth-last-child(2)'));
                $('#' + deleteButtonId).fadeIn();

                // wire up an event handler to the delete button
                google.maps.event.addDomListener(document.getElementById(deleteButtonId), 'click', self.deleteSelectedShape);
            });

            self.initializeEventHandlers();

            Rock.dialogs.updateModalScrollBar(self.controlId);
        };

        var exports = {
            googleMapsLoadCallback: function () {
                // callback for when google maps api is done loading (if it wasn't loaded already)
                $.each(Rock.controls.geoPicker.geoPickerOptions, function (a, options) {
                    var geoPicker = Rock.controls.geoPicker.geoPickers[options.controlId];
                    if (!geoPicker) {

                        geoPicker = new GeoPicker(options);
                        Rock.controls.geoPicker.geoPickers[options.controlId] = geoPicker;
                        geoPicker.initialize();
                    }
                });
            },
            geoPickers: {},
            geoPickerOptions: {},
            findControl: function (controlId) {
                return exports.geoPickers[controlId];
            },
            initialize: function (options) {
                if (!options.controlId) throw '`controlId` is required.';
                exports.geoPickerOptions[options.controlId] = options;

                $(window).on('googleMapsIsLoaded', this.googleMapsLoadCallback);

                // if the google maps api isn't loaded uet, googleMapsLoadCallback will take care of it
                if (typeof (google) != "undefined") {
                    // null it out just in case, to force it to get recreated
                    exports.geoPickers[options.controlId] = null;
                    $(window).trigger('googleMapsIsLoaded');
                }
            }
        };

        return exports;
    }());
}(jQuery));;
(function ($) {
    'use strict';
    window.Rock = window.Rock || {};

    Rock.htmlEditor = (function () {
        var exports = {
            // full list of available items is at http://summernote.org/deep-dive/#custom-toolbar-popover

            // the toolbar items to include in the HtmlEditor when Toolbar is set to Light 
            toolbar_RockCustomConfigLight:
	            [
                    // [groupName, [list of button]]
                    ['source_group',['rockcodeeditor']],
                    ['style_group1', ['bold', 'italic', 'underline', 'strikethrough', 'ol', 'ul', 'link']],
                    ['style_group2', ['undo', 'redo']],
                    ['style_group3', ['clear']],
                    ['style_group4', ['style']],
                    ['para', ['paragraph']],
                    ['plugins1', ['rockmergefield']],
                    ['plugins2', ['rockimagebrowser', 'rockfilebrowser']],
                    ['plugins3', ['rockpastetext', 'rockpastefromword']],
                    ['help_group1', ['help']]
	            ],

            // the toolbar items to include in the HtmlEditor when Toolbar is set to Full 
            toolbar_RockCustomConfigFull:
                [
                    // [groupName, [list of button]]
                    ['source_group', ['rockcodeeditor']],
                    ['style_group1', ['bold', 'italic', 'underline', 'strikethrough', 'ol', 'ul', 'link']],
                    ['style_group2', ['undo', 'redo']],
                    ['style_group3', ['clear']],
                    ['style_group4', ['style']],
                    ['full_toolbar_only', ['fontname', 'fontsize', 'color', 'superscript', 'subscript', 'table', 'hr']],
                    ['para', ['paragraph']],
                    ['plugins1', ['rockmergefield']],
                    ['plugins2', ['rockimagebrowser', 'rockfilebrowser']],
                    ['plugins3', ['rockpastetext', 'rockpastefromword']],
                    ['help_group1', ['help']]

                ]
        }

        return exports;

    }());
}(jQuery));;
(function ($) {
    'use strict';
    window.Rock = window.Rock || {};
    Rock.controls = Rock.controls || {};

    Rock.controls.imageUploader = (function () {
        var _configure = function (options) {
            options.isBinaryFile = options.isBinaryFile || 'T';

            // default setImageUrlOnUpload to true if not specified
            if (options.setImageUrlOnUpload == null) {
                options.setImageUrlOnUpload = true;
            }

            var wsUrl = Rock.settings.get('baseUrl')
                        + 'ImageUploader.ashx?'
                        + 'isBinaryFile=' + options.isBinaryFile;

            if (options.isBinaryFile == 'T') {
                wsUrl += '&fileId=' + options.fileId
                    + '&fileTypeGuid=' + options.fileTypeGuid;
            }
            else {
                // note rootFolder is encrypted to prevent direct access to filesystem via the URL
                wsUrl += '&rootFolder=' + (encodeURIComponent(options.rootFolder) || '');
            }

            // uses https://github.com/blueimp/jQuery-File-Upload
            $('#' + options.controlId).fileupload({
                url: wsUrl,
                dataType: 'json',
                dropZone: $('#' + options.controlId).closest('.imageupload-dropzone'),
                autoUpload: true,
                submit: options.submitFunction,
                start: function (e, data) {
                    var $el = $('#' + options.controlId).closest('.imageupload-group');
                    $el.find('.js-upload-progress').rockFadeIn();
                },
                progressall: function (e, data) {
                    // var $el = $('#' + options.controlId).closest('.imageupload-group');
                    // implement this to show progress percentage
                },
                stop: function (e) {
                    var $el = $('#' + options.controlId).closest('.imageupload-group');
                    $el.find('.js-upload-progress').hide();
                    $el.find('.imageupload-dropzone').rockFadeIn();
                },
                done: function (e, data) {
                    var $el = $('#' + options.imgThumbnail);
                    $('#' + options.hfFileId).val(data.response().result.Id);
                    var getImageUrl = Rock.settings.get('baseUrl')
                        + 'GetImage.ashx?'
                        + 'isBinaryFile=' + (options.isBinaryFile || 'T')
                        + '&id=' + data.response().result.Id
                        + '&fileName=' + data.response().result.FileName
                        + '&width=500';

                    if (options.rootFolder) {
                        // note rootFolder is encrypted to prevent direct access to filesystem via the URL
                        getImageUrl += '&rootFolder=' + encodeURIComponent(options.rootFolder);
                    }

                    if (options.setImageUrlOnUpload) {
                        if ($el.is('img')) {
                            $el.attr('src', getImageUrl);
                        }
                        else {
                            $el.attr('style', 'background-image:url("' + getImageUrl + '");background-size:cover;background-position:50%');
                        }
                    }

                    $('#' + options.aRemove).show();
                    if (options.postbackScript) {
                        window.location = "javascript:" + options.postbackScript;
                    }

                    if (options.doneFunction) {
                        options.doneFunction(e, data);
                    }
                },
                fail: function (e, data) {
                    var $el = $('#' + options.controlId).closest('.imageupload-group');
                    $el.siblings('.js-rockupload-alert').remove();
                    var $warning = $('<div class="alert alert-warning alert-dismissable js-rockupload-alert"/>');

                    var msg = "unable to upload";
                    if (data.response().jqXHR && data.response().jqXHR.status == 406) {
                        msg = "file type not allowed";
                    } else if (data.response().jqXHR && data.response().jqXHR.responseText) {
                        msg = data.response().jqXHR.responseText;
                    }

                    if (options.maxUploadBytes && data.total) {
                        if (data.total >= options.maxUploadBytes) {
                            msg = "file size is limited to " + (options.maxUploadBytes / 1024 / 1024) + "MB";
                        }
                    }

                    $warning.append('<button type="button" class="close" data-dismiss="alert" aria-hidden="true">&times;</button>')
                        .append('<strong><i class="fa fa-exclamation-triangle"></i> Warning </strong>')
                        .append(msg);
                    $warning.insertBefore($el);
                }
            });

            $('#' + options.aRemove).click(function () {
                $(this).hide();
                var $el = $('#' + options.imgThumbnail);
                var noPictureUrl = options.noPictureUrl || Rock.settings.get('baseUrl') + 'Assets/Images/no-picture.svg';
                if ($el.is('img')) {
                    $el.attr('src', noPictureUrl);
                }
                else {
                    $el.attr('style', 'background-image:url(' + noPictureUrl + ');background-size:cover;background-position:50%');
                }
                if (options.postbackRemovedScript) {
                    window.location = "javascript:" + options.postbackRemovedScript;
                } else {
                    $('#' + options.hfFileId).val('0');
                }
                return false;
            });
        },
        exports = {
            initialize: function (options) {
                if (!options.controlId) throw 'Control ID must be set.';
                _configure(options);
            }
        };

        return exports;
    }());
}(jQuery));;
(function ($) {
    'use strict';
    window.Rock = window.Rock || {};
    Rock.controls = Rock.controls || {};

    Rock.controls.itemPicker = (function () {
        var ItemPicker = function (options) {
            this.options = options;

            // set a flag so that the picker only auto-scrolls to a selected item once. This prevents it from scrolling at unwanted times
            this.alreadyScrolledToSelected = false;
        },
            exports;

        ItemPicker.prototype = {
            constructor: ItemPicker,
            initialize: function () {
                var $control = $('#' + this.options.controlId),
                    $tree = $control.find('.treeview'),
                    treeOptions = {
                        multiselect: this.options.allowMultiSelect,
                        restUrl: this.options.restUrl,
                        restParams: this.options.restParams,
                        expandedIds: this.options.expandedIds,
                        id: this.options.startingId
                    },
                    $hfItemIds = $control.find('.js-item-id-value'),
                    $hfExpandedIds = $control.find('.js-initial-item-parent-ids-value');

                if (typeof this.options.mapItems === 'function') {
                    treeOptions.mapping = {
                        mapData: this.options.mapItems
                    };
                }

                // clean up the tree (in case it was initialized already, but we are rebuilding it)
                var rockTree = $tree.data('rockTree');
                if (rockTree) {
                    rockTree.nodes = [];
                }
                $tree.empty();

                $control.find('.scroll-container').tinyscrollbar({ size: 120, sizethumb: 20 });
                // Since some hanlers are "live" events, they need to be bound before tree is initialized
                this.initializeEventHandlers();

                if ($hfItemIds.val() && $hfItemIds !== '0') {
                    treeOptions.selectedIds = $hfItemIds.val().split(',');
                }

                if ($hfExpandedIds.val()) {
                    treeOptions.expandedIds = $hfExpandedIds.val().split(',');
                }

                $tree.rockTree(treeOptions);
                this.updateScrollbar();
            },
            initializeEventHandlers: function () {
                var self = this,
                    $control = $('#' + this.options.controlId),
                    $spanNames = $control.find('.selected-names'),
                    $hfItemIds = $control.find('.js-item-id-value'),
                    $hfItemNames = $control.find('.js-item-name-value');

                // Bind tree events
                $control.find('.treeview')
                    .on('rockTree:selected', function () {
                        // intentionally blank
                    })
                    .on('rockTree:itemClicked', function (e) {
                        // make sure it doesn't autoscroll after something has been manually clicked
                        self.alreadyScrolledToSelected = true;
                        if (!self.options.allowMultiSelect) {
                            $control.find('.picker-btn').trigger('click');
                        }
                    })
                    .on('rockTree:expand rockTree:collapse rockTree:dataBound', function (evt) {
                        self.updateScrollbar();
                    })
                    .on('rockTree:rendered', function (evt) {
                        self.scrollToSelectedItem();
                    });

                $control.find('a.picker-label').click(function (e) {
                    e.preventDefault();
                    $control.find('.picker-menu').first().toggle(function () {
                        self.scrollToSelectedItem();
                    });
                });

                $control.find('.picker-cancel').click(function () {
                    $(this).closest('.picker-menu').slideUp(function () {
                        self.updateScrollbar();
                    });
                });

                // have the X appear on hover if something is selected
                if ($hfItemIds.val() && $hfItemIds.val() !== '0') {
                    $control.find('.picker-select-none').addClass('rollover-item');
                    $control.find('.picker-select-none').show();
                }

                $control.find('.picker-btn').click(function (el) {

                    var rockTree = $control.find('.treeview').data('rockTree'),
                            selectedNodes = rockTree.selectedNodes,
                            selectedIds = [],
                            selectedNames = [];

                    $.each(selectedNodes, function (index, node) {
                        selectedIds.push(node.id);
                        selectedNames.push(node.name);
                    });

                    $hfItemIds.val(selectedIds.join(','));
                    $hfItemNames.val(selectedNames.join(','));

                    // have the X appear on hover. something is selected
                    $control.find('.picker-select-none').addClass('rollover-item');
                    $control.find('.picker-select-none').show();

                    $spanNames.text(selectedNames.join(', '));

                    $(this).closest('.picker-menu').slideUp(function () {
                        self.updateScrollbar();
                    });
                    
                    if (!(el && el.originalEvent && el.originalEvent.srcElement == this)) {
                        // if this event was called by something other than the button itself, make sure the execute the href (which is probably javascript)
                        var jsPostback = $(this).attr('href');
                        if (jsPostback) {
                            window.location = jsPostback;
                        }
                    }
                });

                $control.find('.picker-select-none').click(function (e) {
                    e.stopImmediatePropagation();
                    var rockTree = $control.find('.treeview').data('rockTree');
                    rockTree.clear();
                    $hfItemIds.val('0');
                    $hfItemNames.val('');

                    // don't have the X appear on hover. nothing is selected
                    $control.find('.picker-select-none').removeClass('rollover-item');
                    $control.find('.picker-select-none').hide();

                    $control.siblings('.js-hide-on-select-none').hide();

                    $spanNames.text(self.options.defaultText);
                });
            },
            updateScrollbar: function (sPosition) {
                // first, update this control's scrollbar, then the modal's
                var $container = $('#' + this.options.controlId).find('.scroll-container')

                if ($container.is(':visible')) {
                    if (!sPosition) {
                        sPosition = 'relative'
                    }
                    $container.tinyscrollbar_update(sPosition);
                }

                // update the outer modal  
                Rock.dialogs.updateModalScrollBar(this.options.controlId);
            },
            scrollToSelectedItem: function () {
                var $selectedItem = $('#' + this.options.controlId).find('.picker-menu').find('.selected').first()
                if ($selectedItem.length && (!this.alreadyScrolledToSelected)) {
                    var $scrollContainer = $selectedItem.closest('.scroll-container');
                    var itemTop = $selectedItem.offset().top
                    var itemBottom = $selectedItem.offset().top + $selectedItem.height();
                    var viewportTop = $scrollContainer.offset().top;
                    var viewportBottom = $scrollContainer.offset().top + $scrollContainer.height();

                    // scroll so the item is at top if it isn't already showing within the viewport
                    if (itemTop < viewportTop || itemBottom > viewportBottom) {
                        var treeview = $selectedItem.closest('.treeview');
                        var pPosition = $selectedItem.offset().top - treeview.offset().top;
                        // initialize/update the scrollbar and set to a specific position
                        this.updateScrollbar(pPosition);
                        this.alreadyScrolledToSelected = true;
                    }
                    else {
                        // initialize/update the scrollbar 
                        this.updateScrollbar();
                    }
                } else {
                    // initialize/update the scrollbar 
                    this.updateScrollbar();
                }
            }
        };

        exports = {
            defaults: {
                id: 0,
                controlId: null,
                restUrl: null,
                restParams: null,
                allowMultiSelect: false,
                defaultText: '',
                selectedIds: null,
                expandedIds: null
            },
            controls: {},
            initialize: function (options) {
                var settings,
                    itemPicker;

                if (!options.controlId) throw 'controlId must be set';
                if (!options.restUrl) throw 'restUrl must be set';

                settings = $.extend({}, exports.defaults, options);

                if (!settings.defaultText) {
                    settings.defaultText = exports.defaults.defaultText;
                }

                itemPicker = new ItemPicker(settings);
                exports.controls[settings.controlId] = itemPicker;
                itemPicker.initialize();
            }
        };

        return exports;
    }());
}(jQuery));;
(function ($) {
    'use strict';
    window.Rock = window.Rock || {};
    Rock.controls = Rock.controls || {};

    Rock.controls.mediaPlayer = (function () {
        var exports = {
            initialize: function () {

                Sys.Application.add_load(function () {
                    var cssFile = Rock.settings.get('baseUrl') + 'Scripts/mediaelementjs/mediaelementplayer.min.css';
                    var jsFile = Rock.settings.get('baseUrl') + 'Scripts/mediaelementjs/mediaelement-and-player.js';

                    // ensure that css for mediaelementplayers is added to page
                    if (!$('#mediaElementCss').length) {
                        $('head').append("<link id='mediaElementCss' href='" + cssFile + "' type='text/css' rel='stylesheet' />");
                    }

                    // ensure that js for mediaelementplayers is added to page
                    if (!$('#mediaElementJs').length) {
                        // by default, jquery adds a cache-busting parameter on dynamically added script tags. set the ajaxSetup cache:true to prevent this
                        $.ajaxSetup({ cache: true });
                        $('head').prepend("<script id='mediaElementJs' src='" + jsFile + "' />");
                    }
                    
                    // ensure that mediaelementplayer is applied to all the the rock audio/video that was generated from a Rock Video/Audio FieldType (js-media-audio,js-media-video)
                    $('audio.js-media-audio,video.js-media-video').mediaelementplayer({ enableAutosize: true });
                });

            }
        };

        return exports;
    }());
}(jQuery));;
(function ($) {
    'use strict';
    window.Rock = window.Rock || {};
    Rock.controls = Rock.controls || {};

    Rock.controls.modal = (function () {
        // shows the IFrame #modal-popup modal
        var _showModalPopup = function (sender, popupUrl) {
            var $modalPopup = $('#modal-popup');
            var $modalPopupIFrame = $modalPopup.find('iframe');

            // Use the anchor tag's title attribute as the title of the dialog box
            if (sender.attr('title') != undefined) {
                $('#modal-popup_panel h3').html(sender.attr('title') + ' <small></small>');
            }

            $modalPopupIFrame.height('auto');

            $modalPopupIFrame.one('load', function () {

                // now that the iframe is loaded, show it, set it's initial height and do a modal layout
                $('#modal-popup').fadeTo(0, 1);

                var newHeight = $(this.contentWindow.document).height();
                if ($(this).height() != newHeight) {
                    $(this).height(newHeight);
                }

                $('body').addClass('modal-open');
                $('#modal-popup').modal('layout');
            });

            // Use the anchor tag's href attribute as the source for the iframe
            // this will trigger the load event (above) which will show the popup
            $('#modal-popup').fadeTo(0, 0);
            $modalPopupIFrame.attr('src', popupUrl);
            $('#modal-popup').modal({
                show: true,
                backdrop: 'static',
                keyboard: false,
                attentionAnimation: '',
                modalOverflow: true
            });
        },

        // shows a non-IFrame modal dialog control
        _showModalControl = function ($modalDialog, managerId) {
            $('body').addClass('modal-open');
            $modalDialog.modal({
                show: true,
                manager: managerId,
                backdrop: 'static',
                keyboard: false,
                attentionAnimation: '',
                modalOverflow: true,
                replace: true
            });
        },

        exports = {
            // updates the side of the modal that the control is in.  
            // this function works for both the IFrame modal and ModalDialog control
            updateSize: function (controlId) {
                var $control = typeof (controlId) == 'string' ? $('#' + controlId) : $(controlId);
                if ($control && $control.length) {
                    var $modalBody = $control.closest('.modal-body');
                    if ($modalBody.is(':visible')) {
                        $modalBody[0].style.minHeight = "0px";
                        var scrollHeight = $modalBody.prop('scrollHeight');
                        if ($modalBody.outerHeight() != scrollHeight) {
                            // if modalbody didn't already grow to fit (maybe because of a bootstrap dropdown) make modal-body big enough to fit.
                            $modalBody[0].style.minHeight = scrollHeight + "px";

                            // force the resizeDetector to fire
                            if ($('#dialog').length && $('#dialog')[0].resizedAttached) {
                                $('#dialog')[0].resizedAttached.call();
                            }
                        }
                    }
                }

            },
            // closes the #modal-popup modal (IFrame Modal)
            close: function (msg) {
                // do a setTimeout so this fires after the postback
                $('#modal-popup').hide();
                setTimeout(function () {
                    $('#modal-popup iframe').attr('src', '');
                    $('#modal-popup').modal('hide');

                }, 0);

                $('body').removeClass('modal-open');

                if (msg && msg != '') {

                    if (msg == 'PAGE_UPDATED') {
                        location.reload(true);
                    }
                    else {
                        $('#rock-config-trigger-data').val(msg);
                        $('#rock-config-trigger').click();
                    }
                }
            },
            // closes a ModalDialog control (non-IFrame Modal) 
            closeModalDialog: function ($modalDialog) {
                if ($modalDialog && $modalDialog.length && $modalDialog.modal) {
                    $modalDialog.modal('hide');
                }

                // if all modals are closed, remove all the modal-open class 
                if (!$('.modal').is(':visible')) {
                    {
                        $('.modal-open').removeClass('modal-open');
                    }
                }
            },
            // shows the #modal-popup modal (IFrame Modal)
            show: function (sender, popupUrl, detailsId, postbackUrl) {
                _showModalPopup(sender, popupUrl);
            },
            // shows a ModalDialog control (non-IFrame Modal) 
            showModalDialog: function ($modalDialog, managerId) {
                _showModalControl($modalDialog, managerId);
            },

            // gets the IFrame element of the global the Modal Popup (for the IFrame Modal)
            getModalPopupIFrame: function () {
                var $modalPopup = $('#modal-popup');
                var $modalPopupIFrame = $modalPopup.find('iframe');

                return $modalPopupIFrame;
            }
        };

        return exports;
    }());
}(jQuery));;
(function ($) {
    'use strict';
    window.Rock = window.Rock || {};
    Rock.controls = Rock.controls || {};

    Rock.controls.numberUpDown = (function () {

        var exports = {
            adjust: function (btn, adjustment) {

                var $parent = $(btn).closest('div.numberincrement');
                var $min = $parent.find('.js-number-up-down-min').first();
                var $max = $parent.find('.js-number-up-down-max').first();
                var $value = $parent.find('.js-number-up-down-value').first();
                var $lbl = $parent.find('.js-number-up-down-lbl').first();
                var $upBtn = $parent.find('.js-number-up').first();
                var $downBtn = $parent.find('.js-number-down').first();

                // Get the min, max, and new value
                var minValue = parseInt($min.val(), 10);
                var maxValue = parseInt($max.val(), 10);
                var numValue = parseInt($value.val(), 10) + adjustment;

                // If new value is valid, set the hf and lbl
                if (numValue >= minValue && numValue <= maxValue) {
                    $value.val(numValue);
                    $lbl.html(numValue);
                }

                // enable/disable the 'up' button
                if (numValue >= maxValue) {
                    $upBtn.addClass('disabled');
                } else {
                    $upBtn.removeClass('disabled');
                }

                // enable/disable the 'down' button
                if (numValue <= minValue) {
                    $downBtn.addClass('disabled');
                } else {
                    $downBtn.removeClass('disabled');
                }
            }
        };

        return exports;
    }());
}(jQuery));;
(function ($) {
    'use strict';
    window.Rock = window.Rock || {};
    Rock.controls = Rock.controls || {};

    Rock.controls.personPicker = (function () {
        var PersonPicker = function (options) {
            this.controlId = options.controlId;
            this.restUrl = options.restUrl;
            this.restDetailUrl = options.restDetailUrl;
            this.defaultText = options.defaultText || '';
        };

        PersonPicker.prototype.initializeEventHandlers = function () {
            var controlId = this.controlId,
                restUrl = this.restUrl,
                restDetailUrl = this.restDetailUrl || (Rock.settings.get('baseUrl') + 'api/People/GetSearchDetails'),
                defaultText = this.defaultText;

            var includeBusinesses = $('#' + controlId).find('.js-include-businesses').val() == '1' ? 'true' : 'false';

            var promise = null;

            $('#' + controlId + '_personPicker').autocomplete({
                source: function (request, response) {

                    // abort any searches that haven't returned yet, so that we don't get a pile of results in random order
                    if (promise && promise.state() === 'pending') {
                        promise.abort();
                    }

                    promise = $.ajax({
                        url: restUrl + "?name=" + encodeURIComponent(request.term) + "&includeHtml=false&includeDetails=false&includeBusinesses=" + includeBusinesses + "&includeDeceased=true",
                        dataType: 'json'
                    });

                    promise.done(function (data) {
                        $('#' + controlId + '_personPickerItems').first().html('');
                        response($.map(data, function (item) {
                            return item;
                        }));

                        exports.personPickers[controlId].updateScrollbar();
                    });

                    promise.fail(function (xhr, status, error) {
                        console.log(status + ' [' + error + ']: ' + xhr.responseText);
                        var errorCode = xhr.status;
                        if (errorCode == 401) {
                            $('#' + controlId + '_personPickerItems').first().html("<li class='text-danger'>Sorry, you're not authorized to search.</li>");
                        }
                    });
                },
                minLength: 3,
                html: true,
                appendTo: '#' + controlId + '_personPickerItems',
                pickerControlId: controlId,
                messages: {
                    noResults: function () { },
                    results: function () { }
                }
            });

            $('#' + controlId + ' a.picker-label').click(function (e) {
                e.preventDefault();
                $('#' + controlId).find('.picker-menu').first().slideToggle(function () {
                    exports.personPickers[controlId].updateScrollbar();
                    $(this).find('.picker-search').focus();
                });
            });

            $('#' + controlId + ' .picker-select').on('click', '.picker-select-item :input', function (e) {
                e.stopPropagation();

                var $selectedItem = $(this).closest('.picker-select-item');

                var selectedPersonId = $selectedItem.attr('data-person-id');
                var alreadySelected = $selectedItem.find('.picker-select-item-details').is(':visible');
                if (alreadySelected) {
                    $('#' + controlId + '_btnSelect').get(0).click();
                }

                // hide other open details
                $('#' + controlId + ' .picker-select-item-details').each(function () {
                    var $el = $(this),
                       currentPersonId = $el.closest('.picker-select-item').attr('data-person-id');

                    if (currentPersonId != selectedPersonId) {
                        $el.slideUp();
                    }
                });

                var $itemDetails = $selectedItem.find('.picker-select-item-details');

                if ($itemDetails.attr('data-has-details') == 'false') {
                    // add a spinner in case we have to wait on the server for a little bit
                    var $spinner = $selectedItem.find('.loading-notification');
                    $spinner.fadeIn(800);

                    // fetch the search details from the server
                    $.get(restDetailUrl + '?Id=' + selectedPersonId, function (responseText, textStatus, jqXHR) {
                        $itemDetails.attr('data-has-details', true);

                        // hide then set the html so that we can get the slideDown effect
                        $itemDetails.stop().hide().html(responseText);
                        $itemDetails.slideDown(function () {
                            exports.personPickers[controlId].updateScrollbar();
                        });

                        $spinner.stop().fadeOut(200);
                    });
                } else {
                    $selectedItem.find('.picker-select-item-details:hidden').slideDown(function () {
                        exports.personPickers[controlId].updateScrollbar();
                    });
                }
            });

            $('#' + controlId).hover(
                function () {

                    // only show the X if there there is something picked
                    if ($('#' + controlId + '_hfPersonId').val() || '0' !== '0') {
                        $('#' + controlId + '_btnSelectNone').stop().show();
                    }
                },
                function () {
                    $('#' + controlId + '_btnSelectNone').fadeOut(500);
                });

            $('#' + controlId + '_btnCancel').click(function () {
                $(this).closest('.picker-menu').slideUp(function () {
                    exports.personPickers[controlId].updateScrollbar();
                });
            });

            $('#' + controlId + '_btnSelectNone').click(function (e) {

                var selectedValue = '0',
                    selectedText = defaultText,
                    $selectedItemLabel = $('#' + controlId + '_selectedItemLabel'),
                    $hiddenItemId = $('#' + controlId + '_hfPersonId'),
                    $hiddenItemName = $('#' + controlId + '_hfPersonName');

                $hiddenItemId.val(selectedValue);
                $hiddenItemName.val(selectedText);
                $selectedItemLabel.val(selectedValue);
                $selectedItemLabel.text(selectedText);
            });

            var setSelectedPerson = function (selectedValue, selectedText) {
                var selectedPersonLabel = $('#' + controlId + '_selectedPersonLabel'),
                    hiddenPersonId = $('#' + controlId + '_hfPersonId'),
                    hiddenPersonName = $('#' + controlId + '_hfPersonName');

                hiddenPersonId.val(selectedValue);
                hiddenPersonName.val(selectedText);

                selectedPersonLabel.val(selectedValue);
                selectedPersonLabel.text(selectedText);

                $('#' + controlId).find('.picker-menu').slideUp();
            }

            $('#' + controlId + '_btnSelect').click(function () {
                var radInput = $('#' + controlId).find('input:checked'),
                    selectedValue = radInput.val(),
                    selectedText = radInput.closest('.picker-select-item').find('label').text();

                setSelectedPerson(selectedValue, selectedText);
            });

            $('#' + controlId + ' .js-select-self').on('click', function () {
                var selectedValue = $('#' + controlId + ' .js-self-person-id').val(),
                    selectedText = $('#' + controlId + ' .js-self-person-name').val();

                setSelectedPerson(selectedValue, selectedText);

                // fire the postBack of the btnSelect if there is one
                var postBackUrl = $('#' + controlId + '_btnSelect').prop('href');
                if (postBackUrl) {
                    window.location = postBackUrl;
                }
            });
        };

        PersonPicker.prototype.updateScrollbar = function () {
            // update the outer modal scrollbar
            Rock.dialogs.updateModalScrollBar(this.controlId);
        }

        PersonPicker.prototype.initialize = function () {
            $.extend($.ui.autocomplete.prototype, {
                _renderItem: function ($ul, item) {
                    if (this.options.html) {
                        // override jQueryUI autocomplete's _renderItem so that we can do Html for the listitems
                        // derived from http://github.com/scottgonzalez/jquery-ui-extensions

                        var inactiveWarning = "";

                        if (!item.IsActive) {
                            inactiveWarning = " <small>(Inactive)</small>";
                        }

                        var $div = $('<div/>').attr('class', 'radio'),

                            $label = $('<label/>')
                                .html(item.Name + inactiveWarning +  ' <i class="fa fa-refresh fa-spin margin-l-md loading-notification" style="display: none; opacity: .4;"></i>')
                                .prependTo($div),

                            $radio = $('<input type="radio" name="person-id" />')
                                .attr('id', item.Id)
                                .attr('value', item.Id)
                                .prependTo($label),

                            $li = $('<li/>')
                                .addClass('picker-select-item')
                                .attr('data-person-id', item.Id)
                                .html($div),

                            $resultSection = $(this.options.appendTo);

                        if (item.PickerItemDetailsHtml) {
                            $(item.PickerItemDetailsHtml).appendTo($li);
                        }
                        else {
                            var $itemDetailsDiv = $('<div/>')
                                .addClass('picker-select-item-details clearfix')
                                .attr('data-has-details', false)
                                .hide();

                            $itemDetailsDiv.appendTo($li);
                        }

                        if (!item.IsActive) {
                            $li.addClass('is-inactive');
                        }

                        return $resultSection.append($li);
                    }
                    else {
                        return $('<li></li>')
                            .data('item.autocomplete', item)
                            .append($('<a></a>').text(item.label))
                            .appendTo($ul);
                    }
                }
            });

            this.initializeEventHandlers();
        };

        var exports = {
            personPickers: {},
            findControl: function (controlId) {
                return exports.personPickers[controlId];
            },
            initialize: function (options) {
                if (!options.controlId) throw '`controlId` is required.';
                if (!options.restUrl) throw '`restUrl` is required.';

                var personPicker = new PersonPicker(options);
                exports.personPickers[options.controlId] = personPicker;
                personPicker.initialize();
            }
        };

        return exports;
    }());
}(jQuery));;
(function ($) {
    'use strict';
    window.Rock = window.Rock || {};
    Rock.controls = Rock.controls || {};

    Rock.controls.rangeSlider = (function () {
        var exports = {
            initialize: function (options) {
                if (!options.controlId) {
                    throw 'controlId is required';
                }

                Sys.Application.add_load(function () {
                    var cssFile = Rock.settings.get('baseUrl') + 'Scripts/ion.rangeSlider/css/ion.rangeSlider.css';
                    var cssSkinFile = Rock.settings.get('baseUrl') + 'Scripts/ion.rangeSlider/css/ion.rangeSlider.skinHTML5.css';
                    var jsFile = Rock.settings.get('baseUrl') + 'Scripts/ion.rangeSlider/js/ion-rangeSlider/ion.rangeSlider.min.js';

                    // ensure that css for rangeSlider is added to page
                    if (!$('#rangeSliderCss').length) {
                        $('head').append("<link id='rangeSliderCss' href='" + cssFile + "' type='text/css' rel='stylesheet' />");
                    }

                    // ensure that skin css for rangeSlider is added to page
                    if (!$('#rangeSliderSkinCss').length) {
                        $('head').append("<link id='rangeSliderSkinCss' href='" + cssSkinFile + "' type='text/css' rel='stylesheet' />");
                    }
                });

                // use https://github.com/IonDen/ion.rangeSlider/ to make a slider
                // see https://github.com/IonDen/ion.rangeSlider/#settings for settings
                $('#' + options.controlId).ionRangeSlider({
                    type: options.type || 'single', // Choose slider type, could be 'single' for one handle, or 'double' for two handles
                    min: options.min || 0,
                    max: options.max || 100,
                    from: options.from || null, // for 'single' the position of the slider. for 'double' the lower position of the selected range
                    to: options.to || null // if 'double' the upper position of the selected range
                });

            }
        };

        return exports;
    }());
}(jQuery));;
(function ($, Sys) {
    'use strict';
    window.Rock = window.Rock || {};
    Rock.controls = Rock.controls || {};

    Rock.controls.scheduleBuilder = (function () {
        var exports,
            ScheduleBuilder = function (options) {
                this.id = options.id;
            };

        ScheduleBuilder.prototype.initializeEventHandlers = function () {

            var id = this.id,
                $modal = $('#' + id).closest('.rock-modal');


            $modal.find('.schedule-type').off('click').on('click',function () {
                var recurrenceState = $('input[class=schedule-type]:checked').data('schedule-type');

                if (recurrenceState === 'schedule-onetime') {
                    $modal.find('.js-schedule-recurrence-panel').slideUp();
                } else {
                    $modal.find('.js-schedule-recurrence-panel').slideDown();
                }
            });

            $modal.find('.recurrence-pattern-radio').off('click').on('click', function () {

                var recurrencePattern = '.' + $('input[class=recurrence-pattern-radio]:checked').data('recurrence-pattern');

                if ($modal.find(recurrencePattern)) {

                    $modal.find('.recurrence-pattern-type').not(recurrencePattern).hide();

                    if (recurrencePattern == ".recurrence-pattern-specific-date") {
                        /* don't show continue-until or exclusion dates for specific date mode (since it doesn't make sense, plus ical ends up deleting them) */
                        $modal.find('.js-continue-until').hide();
                        $modal.find('.js-exclusion-dates').hide();
                    }
                    else {
                        $modal.find('.js-continue-until').show();
                        $modal.find('.js-exclusion-dates').show();
                    }

                    $(recurrencePattern).fadeIn();
                }
            });

            /** Specific Dates Scripts**/

            // show datepicker, ok, cancel so that new date can be added to the list
            $modal.find('.add-specific-date').off('click').on('click', function () {
                $(this).hide();
                $modal.find('.js-add-specific-date-group').show();
            });

            // add new date to list when ok is clicked
            $modal.find('.add-specific-date-ok').off('click').on('click', function () {

                // get date list from hidden field
                var dateListValues = $modal.find('.recurrence-pattern-type > input:hidden').val().split(',');

                if (!dateListValues[0]) {
                    // if dateList is blank, initialize as a new empty array
                    dateListValues = [];
                }

                // validate

                // set colors back to default just in case previously marked invalid
                var $datepicker = $modal.find('.specific-date input');
                $datepicker.css('color', '');
                var checkDate = Date.parse($datepicker.val());
                if (!checkDate) {
                    // blank, don't color, just return
                    return;
                }

                if (checkDate < 0) {
                    // invalid date entered, color red and return
                    $datepicker.css('color', 'red');
                    return;
                }

                var newDate = $datepicker.val();

                // delete newDate from list in case it is already there
                var index = dateListValues.indexOf(newDate);
                if (index >= 0) {
                    dateListValues.splice(index, 1);
                }

                // add new date to list
                dateListValues.push(newDate);

                // save list back to hidden field
                $modal.find('.js-specific-datelist-values').val(dateListValues);

                // rebuild the UL
                var dateList = $modal.find(".lstSpecificDates");
                dateList.children().remove();
                $.each(dateListValues, function (i, value) {
                    // add to ul
                    var newLi = "<li><span>" + value + "</span> <a href='#' style='display: none'><i class='fa fa-times'></i></a></li>";
                    dateList.append(newLi);
                });

                $modal.find('.js-add-specific-date-group').hide();
                $modal.find('.add-specific-date').show();
            });

            // cancel out of adding a new date
            $modal.find('.add-specific-date-cancel').off('click').on('click', function () {
                $modal.find('.js-add-specific-date-group').hide();
                $modal.find('.add-specific-date').show();
            });

            // fadeIn/fadeOut the X buttons to delete dates
            $modal.find('.lstSpecificDates').hover(
                function () {
                    $(this).find('li a').stop(true, true).show();
                },
                function () {
                    $(this).find('li a').stop(true, true).fadeOut(500);
                }
            );

            // delete specific date from list
            $modal.find('.lstSpecificDates').off('click').on('click', 'li a', function () {
                var selectedDate = $(this).siblings().text();

                // get date list from hidden field
                var $hiddenField = $modal.find('.js-specific-datelist-values');
                var dateList = $hiddenField.val().split(",");

                // delete selectedDate
                var index = dateList.indexOf(selectedDate);
                if (index >= 0) {
                    dateList.splice(index, 1);
                }

                // save list back to hidden field
                $hiddenField.val(dateList);

                // remove date from ul list
                var liItem = $(this).parent();
                liItem.remove();
            });

            /** Exclusion DateRanges Scripts **/

            // show dateRangepicker, ok, cancel so that new dateRange can be added to the list
            $modal.find('.add-exclusion-daterange').off('click').on('click', function () {
                
                $(this).hide();
                $modal.find('.js-add-exclusion-daterange-group').show(function () {
                    Rock.controls.modal.updateSize();
                });
            });

            // add new date to list when ok is clicked
            $modal.find('.add-exclusion-daterange-ok').off('click').on('click', function () {

                // get daterange list from hidden field
                var dateRangeListValues = $modal.find('.js-exclusion-daterange-list-values').val().split(",");
                if (!dateRangeListValues[0]) {
                    // if blank, initialize as a new empty array
                    dateRangeListValues = [];
                }

                var $exclusionDateRange = $modal.find('.js-exclusion-date-range-picker input');
                var newDateRange = $exclusionDateRange.first().val() + ' - ' + $exclusionDateRange.last().val();

                // delete newDateRange from list in case it is already there
                var index = dateRangeListValues.indexOf(newDateRange);
                if (index >= 0) {
                    dateRangeListValues.splice(index, 1);
                }

                // add new dateRange to list
                dateRangeListValues.push(newDateRange);

                // save list back to hidden field
                $modal.find('.js-exclusion-daterange-list-values').val(dateRangeListValues);

                // rebuild the UL
                var dateRangeList = $modal.find('.lstExclusionDateRanges');
                dateRangeList.children().remove();
                $.each(dateRangeListValues, function (i, value) {
                    // add to ul
                    var newLi = "<li><span>" + value + "</span><a href='#' style='display: none'><i class='fa fa-times'></i></a></li>";
                    dateRangeList.append(newLi);
                });

                $modal.find('.js-add-exclusion-daterange-group').hide();
                $modal.find('.add-exclusion-daterange').show();
            });

            // cancel out of adding a new dateRange
            $modal.find('.add-exclusion-daterange-cancel').off('click').on('click', function () {
                $modal.find('.js-add-exclusion-daterange-group').hide();
                $modal.find('.add-exclusion-daterange').show();
            });

            // fadeIn/fadeOut the X buttons to delete dateRanges
            $modal.find('.lstExclusionDateRanges').hover(
                function () {
                    $(this).find('li a').stop(true, true).show();
                },
                function () {
                    $(this).find('li a').stop(true, true).fadeOut(500);
                }
            );

            // delete dateRange from list
            $modal.find('.lstExclusionDateRanges').off('click').on('click', 'li a', function () {
                var selectedDateRange = $(this).siblings("span").text();

                // get dateRange list from hidden field
                var $hiddenField = $modal.find('.js-exclusion-daterange-list-values');
                var dateRangeList = $hiddenField.val().split(",");

                // delete selectedDateRange
                var index = dateRangeList.indexOf(selectedDateRange);
                if (index >= 0) {
                    dateRangeList.splice(index, 1);
                }

                // save list back to hidden field
                $hiddenField.val(dateRangeList);

                // remove dateRange from ul list
                var liItem = $(this).parent();
                liItem.remove();
            });

            // validate on Save.  Make sure they have at least a StartDate and Time set
            $modal.find('.js-modaldialog-save-link').off('click').on('click', function (event) {
                var $datetimepicker = $modal.find('[id*="dpStartDateTime"]').find('input'),
                    startDateValue = Date.parse($datetimepicker.first().val()) || -1,
                    startTimeValue = $datetimepicker.last().val();

                if (startDateValue < 0 || !startTimeValue) {
                    $datetimepicker.parents(".form-group").first().toggleClass("has-error", 1);
                    event.preventDefault();
                    return;
                }
                else {
                    $datetimepicker.parents(".form-group").first().toggleClass("has-error", 0);
                }
            });
        };

        exports = {
            cache: {},
            initialize: function (options) {
                if (!options.id) {
                    throw 'id is required';
                }

                var sb = new ScheduleBuilder(options);
                exports.cache[options.id] = sb;

                Sys.Application.add_load(function () {
                    sb.initializeEventHandlers();
                });
            }
        };

        return exports;
    }());
}(jQuery, Sys));;
(function () {
    'use strict';
    window.Rock = window.Rock || {};
    Rock.controls = Rock.controls || {};

    Rock.controls.searchField = (function () {
        var exports,
            SearchField = function (options) {
                this.controlId = options.controlId;
                this.$el = $('#' + this.controlId);
                this.name = options.name;
            };

        SearchField.prototype = {
            constructor: SearchField,
            initialize: function () {
                var self = this;

                var key = sessionStorage.getItem("com.rockrms.search");
                if (key && key != '') {
                    var $search = self.$el.parents('.smartsearch');
                    $search.find('input:hidden').val(key);
                    $search.find('a.dropdown-toggle > span').html($search.find('li[data-key="' + key + '"] > a').html());
                }

                this.$el.typeahead({
                    name: this.name,
                    limit: 15,
                    remote: {
                        url: Rock.settings.get('baseUrl') + 'api/search?type=%TYPE&term=%QUERY&$top=15',
                        replace: function (url, uriEncodedQuery) {
                            var query = url;
                            query = query.replace('%TYPE', self.$el.parents('.smartsearch').find('input:hidden').val());
                            query = query.replace('%QUERY', uriEncodedQuery);
                            return query;
                        }
                    }
                });

                this.initializeEventHandlers();
            },
            initializeEventHandlers: function () {
                var self = this,
                    search = function (term) {

                        // search for data elements in the search term
                        var $dataEl = $("<p>" + term + "</p>").find("data:first");

                        // see if this is a universal search by looking for return-type and return-id data params
                        var returnType = $dataEl.attr("return-type");
                        var returnId = $dataEl.attr("return-id");

                        if (returnType == null || returnId == null) {
                            var otherParams = '';

                            // take any data attributes and add them as query parameters to the url
                            $dataEl.each(function () {
                                $.each(this.attributes, function () {
                                    if (this) {
                                        otherParams += '&' + this.name + '=' + encodeURIComponent(this.value);
                                    }
                                });
                            });

                            // remove any html from the search term before putting it in the url
                            var targetTerm = $("<div/>").html(term).text().trim();

                            var keyVal = self.$el.parents('.smartsearch').find('input:hidden').val(),
                                $li = self.$el.parents('.smartsearch').find('li[data-key="' + keyVal + '"]'),
                                targetUrl = $li.attr('data-target'),
                                url = Rock.settings.get('baseUrl') + targetUrl.replace('{0}', encodeURIComponent(targetTerm));

                            if (otherParams != '') {
                                if (url.indexOf('?') > -1) {
                                    url += otherParams
                                } else {
                                    url += otherParams.replace(/^&/, '?')
                                }
                            }

                            window.location = url;
                        } else {
                            // universal search uses returnType and returnId, so build the url for that
                            var keyVal = self.$el.parents('.smartsearch').find('input:hidden').val(),
                                $li = self.$el.parents('.smartsearch').find('li[data-key="' + keyVal + '"]'),
                                targetUrl = $li.attr('data-target'),
                                url = Rock.settings.get('baseUrl') + targetUrl.replace('{0}', encodeURIComponent(returnType) + "/" + encodeURIComponent(returnId));

                            window.location = url;
                        }
                    };

                // Listen for typeahead's custom events and trigger search when hit
                this.$el.on('typeahead:selected typeahead:autocompleted', function (e, obj, name) {
                    search(obj.value);
                });

                // Listen for the ENTER key being pressed while in the search box and trigger search when hit
                this.$el.keydown(function (e) {
                    if (e.keyCode === 13) {
                        e.preventDefault();
                        return false;
                    }
                });
                this.$el.keyup(function (e) {
                    if (e.keyCode === 13 && "" !== $(this).val().trim() ) {
                        search($(this).val());
                    }
                });

                // Wire up "change" handler for search type "dropdown menu"
                this.$el.parents('.smartsearch').find('.dropdown-menu a').click(function () {
                    var $this = $(this),
                        text = $this.html();

                    var key = $this.parent().attr('data-key');
                    sessionStorage.setItem("com.rockrms.search", key);

                    $this.parents('.dropdown-menu').siblings('.navbar-link').find('span').html(text);
                    self.$el.parents('.smartsearch').find('input:hidden').val(key)
                });
            }
        };

        exports = {
            defaults: {
                controlId: null,
                name: 'search'
            },
            controls: {},
            initialize: function (options) {
                var searchField,
                    settings = $.extend({}, exports.defaults, options);

                if (!settings.controlId) throw 'controlId is required';
                
                if (!exports.controls[settings.controlId]) {
                    searchField = new SearchField(settings);
                    exports.controls[settings.controlId] = searchField;
                } else {
                    searchField = exports.controls[settings.controlId];
                }

                // Delay initialization until after the DOM is ready
                $(function () {
                    searchField.initialize();
                });
            }
        };

        return exports;
    }());
}());;
(function ($) {
    'use strict';
    window.Rock = window.Rock || {};
    Rock.controls = Rock.controls || {};

    Rock.controls.slidingDateRangePicker = (function () {
        var exports = {
            initialize: function (options) {
                if (!options.id) {
                    throw 'id is required';
                }

                var $picker = $('#' + options.id);

                // the dropdown with current, last, previous, daterange in it
                var $select = $picker.find('.js-slidingdaterange-select');

                showHideControls($picker, $select);
                updateDateRangeInfo($picker);

                $select.on('change', function () {
                    showHideControls($picker, $select);
                    updateDateRangeInfo($picker);
                });

                $('.js-number, .js-time-units-singular, .js-time-units-plural, .js-slidingdaterange-select', $picker).on('change', function () {
                    updateDateRangeInfo($picker);
                });

                $('.js-number', $picker).on('keyup', function () {
                    updateDateRangeInfo($picker);
                });
            },
        },
        showHideControls = function ($picker, $select) {
            var selectedValue = $select.val();
            var isLast = selectedValue == '0';
            var isCurrent = selectedValue == '1';
            var isDateRange = selectedValue == '2';
            var isPrevious = selectedValue == '4';
            var isNext = selectedValue == '8';
            var isUpcoming = selectedValue == '16';
            $picker.find('.js-number').toggle(isLast || isPrevious || isNext || isUpcoming);
            $picker.find('.js-time-units-singular').toggle(isCurrent);
            $picker.find('.js-time-units-plural').toggle(isLast || isPrevious || isNext || isUpcoming);
            $picker.find('.js-time-units-date-range').toggle(isDateRange);
            var $pickerContainer = $picker.closest('.js-slidingdaterange-container');
            $pickerContainer.find('.js-slidingdaterange-info').toggle(isLast || isPrevious || isNext || isUpcoming || isCurrent);
        },
        updateDateRangeInfo = function ($picker) {
            var $select = $picker.find('.js-slidingdaterange-select');
            var timeUnitType = 0;
            if ($picker.find('.js-time-units-singular').is(':visible')) {
                timeUnitType = $picker.find('.js-time-units-singular').val();
            } else {
                timeUnitType = $picker.find('.js-time-units-plural').val();
            }

            var numberOf = $picker.find('.js-number').val();

            var $pickerContainer = $picker.closest('.js-slidingdaterange-container');

            var getDateRangeUrl = Rock.settings.get('baseUrl') + 'api/Utility/CalculateSlidingDateRange?slidingDateRangeType=' + $select.val() + '&timeUnitType=' + timeUnitType + '&number=' + numberOf;
            $.get(getDateRangeUrl, function (r) {
                $pickerContainer.find('.js-slidingdaterange-info').text(r);
            });

            var getTextValueUrl = Rock.settings.get('baseUrl') + 'api/Utility/GetSlidingDateRangeTextValue?slidingDateRangeType=' + $select.val() + '&timeUnitType=' + timeUnitType + '&number=' + numberOf;
            $.get(getTextValueUrl, function (r) {
                $pickerContainer.find('.js-slidingdaterange-text-value').val(r);
            });
        }

        return exports;
    }());
}(jQuery));;
(function ($) {
    'use strict';
    window.Rock = window.Rock || {};
    Rock.controls = Rock.controls || {};

    Rock.controls.tagList = (function () {
        var TagList = function (options) {
                this.controlId = options.controlId;
                this.entityTypeId = options.entityTypeId;
                this.currentPersonId = options.currentPersonId;
                this.entityGuid = options.entityGuid;
                this.entityQualifierColumn = options.entityQualifierColumn;
                this.entityQualifierValue = options.entityQualifierValue;
                this.preventTagCreation = options.preventTagCreation;
                this.delaySave = options.delaySave;
            },
            exports;

        TagList.prototype.verifyTag = function (tagName) {
            // Since `verifyTag` is being called by the jQuery lib, `this`
            // is the current TagList DOM element. Get the HTML ID and fetch
            // from the cache.
            var tagList = exports.tagLists[$(this).attr('id')],
                restUrl = Rock.settings.get('baseUrl') + 'api/tags';
            restUrl += '/' + tagList.entityTypeId;
            restUrl += '/' + tagList.currentPersonId;
            
            if (tagList.entityQualifierColumn) {
                restUrl += '/' + tagList.entityQualifierColumn;
            }

            if (tagList.entityQualifierValue) {
                restUrl += '/' + tagList.entityQualifierValue;
            }

            restUrl += '?name=' + encodeURIComponent(tagName);


            $.ajax({
                url: restUrl,
                statusCode: {
                    404: function () {
                        if (tagList.preventTagCreation) {
                            $('#' + tagList.controlId).removeTag(tagName);
                        }
                        else {
                            Rock.dialogs.confirm('A tag called "' + $('<div/>').text(tagName).html() + '" does not exist. Do you want to create a new personal tag?', function (result) {
                                if (result) {
                                    tagList.addTag(tagName);
                                } else {
                                    $('#' + tagList.controlId).removeTag(tagName);
                                }
                            });
                        }
                    },
                    200: function () {
                        tagList.addTag(tagName);
                    }
                }
            });
        };

        TagList.prototype.addTag = function (tagName) {
            // `addTag` is invoked by `verifyTag` on an instance of a `TagList` object.
            // `this` is the current TagList instance in scope.

            var tagList = this,
                restUrl = Rock.settings.get('baseUrl') + 'api/taggeditems'
            restUrl += '/' + tagList.entityTypeId;
            restUrl += '/' + tagList.currentPersonId;
            restUrl += '/' + tagList.entityGuid;
            restUrl += '?name=' + encodeURIComponent(tagName);

            // only attempt to add tag if an entityGuid exists
            if (!tagList.delaySave) {
                if (tagList.entityQualifierColumn) {
                    restUrl += '/' + tagList.entityQualifierColumn;
                }

                if (tagList.entityQualifierValue) {
                    restUrl += '/' + tagList.entityQualifierValue;
                }

                $.ajax({
                    type: 'POST',
                    url: restUrl,
                    error: function (xhr, status, error) {
                        console.log('AddTag() status: ' + status + ' [' + error + ']: ' + xhr.responseText);
                    }
                });
            }
        };

        TagList.prototype.removeTag = function (tagName) {
            // Since `removeTag` is being called by the jQuery lib, `this`
            // is the current TagList DOM element. Get the HTML ID and fetch
            // from the cache.
            var tagList = exports.tagLists[$(this).attr('id')],
                restUrl = Rock.settings.get('baseUrl') + 'api/taggeditems';
            restUrl += '/' + tagList.entityTypeId;
            restUrl += '/' + tagList.currentPersonId;
            restUrl += '/' + tagList.entityGuid;

            // only attempt to remove tag if an entityGuid exists
            if (!tagList.delaySave) {
                if (tagList.entityQualifierColumn) {
                    restUrl += '/' + tagList.entityQualifierColumn;
                }

                if (tagList.entityQualifierValue) {
                    restUrl += '/' + tagList.entityQualifierValue;
                }

                restUrl += '?name=' + encodeURIComponent(tagName);

                $.ajax({
                    type: 'DELETE',
                    url: restUrl,
                    context: {
                        tagName: tagName,
                        tagsInput: this
                    },
                    error: function (xhr, status, error) {
                        if (xhr && xhr.status == 404) {
                            // already deleted
                            return;
                        }

                        Rock.dialogs.alert("Unable to remove tag: " + error);

                        // put the tag back in (in alpha order, case-insensitive)
                        var tagsCommaList = $(this.tagsInput).val() + ',' + this.tagName

                        tagsCommaList = tagsCommaList.split(",").sort(function (a, b) {
                            return a.toLowerCase().localeCompare(b.toLowerCase());
                        }).join(",");

                        $(this.tagsInput).importTags(tagsCommaList);
                        return false;
                    }
                });
            }

        };

        TagList.prototype.initialize = function () {

            var autoCompleteUrlPrefix = Rock.settings.get('baseUrl') + 'api/tags/availablenames';
            autoCompleteUrlPrefix += '/' + this.entityTypeId;
            autoCompleteUrlPrefix += '/' + this.currentPersonId;

            var autoCompleteUrlSuffix = '/' + this.entityGuid;
            if (this.entityQualifierColumn) {
                autoCompleteUrlSuffix += '/' + this.entityQualifierColumn;
            }
            if (this.entityQualifierValue) {
                autoCompleteUrlSuffix += '/' + this.entityQualifierValue;
            }

            $('ul.ui-autocomplete').css({ 'width': '300px' });

            $('#' + this.controlId).tagsInput({
                autocomplete_url: function (request, response) {
                    $.ajax({
                        url: autoCompleteUrlPrefix + '/' + request.term + autoCompleteUrlSuffix,
                        dataType: 'json',
                        success: function (data, status, xhr) {
                            response($.map(data, function (item) {
                                return {
                                    value: item.Name,
                                    class: !item.OwnerId ? 'system' : 'personal'
                                };
                            }));
                        },
                        error: function (xhr, status, error) {
                            console.log('availablenames status: ' + status + ' [' + error + ']: ' + xhr.reponseText);
                        }
                    });
                },
                autoCompleteAppendTo: 'div.tag-wrap',
                autoCompleteMessages: {
                    noResults: function () {},
                    results: function () {}
                },
                height: 'auto',
                width: '100%',
                interactive: true,
                defaultText: 'add tag',
                removeWithBackspace: false,
                onAddTag: this.verifyTag,
                onRemoveTag: this.removeTag
            });
        };

        exports = {
            tagLists: {},
            initialize: function (options) {
                if (!options.controlId) throw 'controlId must be set.';
                if (!options.entityTypeId) throw 'entityTypeId must be set.';
                if (!options.currentPersonId) throw 'currentPersonId must be set';
                if (!options.entityGuid) throw 'entityGuid must be set';
                
                var tagList = new TagList(options);
                tagList.options = options;
                exports.tagLists[options.controlId] = tagList;
                tagList.initialize();
            }
        };

        return exports;
    }());
}(jQuery));;
(function ($) {
    'use strict';
    window.Rock = window.Rock || {};
    Rock.controls = Rock.controls || {};

    Rock.controls.timePicker = (function () {
        var exports = {
            initialize: function (options) {
                if (!options.id) {
                    throw 'id is required';
                }

                var $tp = $('#' + options.id);

                // bootstrap-timepicker requires that the parent div have bootstrap-timepicker, input-append classes
                $tp.closest('div').addClass('bootstrap-timepicker').addClass('input-append');

                // uses https://github.com/jdewit/bootstrap-timepicker
                $tp.timepicker({
                    defaultTime: false
                });
                
                $tp.closest('.js-timepicker-input').find('.js-timepicker-clear').click(function () {
                    $tp.timepicker('clear');
                });
            }
        };

        return exports;
    }());
}(jQuery));;
(function ($) {
    'use strict';
    window.Rock = window.Rock || {};
    Rock.controls = Rock.controls || {};

    Rock.controls.toggleButton = (function () {
        var exports = {
            initialize: function (options) {
                if (!options.id) {
                    throw 'id is required';
                }

                // uses pattern from http://www.bootply.com/92189

                $('#' + options.id + ' .btn-toggle').click(function (e) {

                    e.stopImmediatePropagation();

                    $(this).find('.btn').toggleClass('active');

                    if (options.activeButtonCssClass && $(this).find('.' + options.activeButtonCssClass).size() > 0) {
                        $(this).find('.btn').toggleClass(options.activeButtonCssClass);
                    }
                    
                    if (options.onButtonCssClass) {
                        $(this).find('.js-toggle-on').toggleClass(options.onButtonCssClass);
                    }

                    if (options.offButtonCssClass) {
                        $(this).find('.js-toggle-off').toggleClass(options.offButtonCssClass);
                    }
                    
                    $(this).parent().find('.js-toggle-checked').val($(this).find('.js-toggle-on').hasClass('active'));

                });

            }
        };

        return exports;
    }());
}(jQuery));



;
(function ($) {
    'use strict';
    window.Rock = window.Rock || {};
    Rock.controls = Rock.controls || {};

    Rock.controls.util = (function () {
        var exports = {
            googleMapsIsLoaded: function () {
                // trigger googleMapsIsLoaded so that controls (like the geoPicker) know about it
                $(window).trigger('googleMapsIsLoaded');
            },
            loadGoogleMapsApi: function (apiSrc) {
                // ensure that js for googleMapsApi is added to page
                if (!$('#googleMapsApi').length) {
                    // by default, jquery adds a cache-busting parameter on dynamically added script tags. set the ajaxSetup cache:true to prevent this
                    $.ajaxSetup({ cache: true });
                    var src = apiSrc + '&callback=Rock.controls.util.googleMapsIsLoaded';
                    $('head').prepend("<script id='googleMapsApi' src='" + src + "' />");
                } else if (typeof google == 'object' && typeof google.maps == 'object') {
                    this.googleMapsIsLoaded();
                }
            }
        };

        return exports;

    }());
}(jQuery));
;
(function ($) {
    'use strict';
    window.Rock = window.Rock || {};
    Rock.controls = Rock.controls || {};

    Rock.controls.yearPicker = (function () {
        var exports = {
            initialize: function (options) {
                if (!options.id) {
                    throw 'id is required';
                }

                var earliestDate = new Date(1000, 1, 1);

                // uses https://github.com/eternicode/bootstrap-datepicker
                $('#' + options.id).datepicker({
                    format: 'yyyy',
                    autoclose: true,
                    startView: 2,
                    minViewMode: 2,
                    startDate: earliestDate
                });

            }
        };

        return exports;
    }());
}(jQuery));;
